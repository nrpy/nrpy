# nrpy/equations/general_relativity/bhahaha/SpECTRESpinEstimate.py
"""
Omega-based quasilocal spin diagnostics on r = h(theta, phi), constructed intrinsically.

All expressions are constructed on the 2-surface without performing explicit
r -> h(theta, phi) substitutions inside the tensor definitions.

Assumptions and scope:

- The coordinate system must be "Spherical".
- The ambient coordinates (xx[0], xx[1], xx[2]) are (r, theta, phi).
- The tensors gammaDD[i][j], KDD[i][j], and sU[i] are given in this same
  spherical coordinate basis, at the surface points.
- The surface is parameterized by (theta, phi) with r = h(theta, phi).
- Under these assumptions, the tangent vectors e_A^i defined below (with
  A,B in {0: theta, 1: phi}) are consistent with
  e_A^i = partial x^i / partial xi^A in the (r, theta, phi) basis.

If your data are provided in a different coordinate basis (e.g., Cartesian),
you must either:

1. Transform gammaDD, KDD, and sU into the spherical basis before using
   this module, or
2. Implement a different embedding and tangent-vector construction consistent
   with your chosen basis.

Eigenfunction normalization (critical):

- The quasilocal spin magnitude S computed from z_alpha and Omega assumes
  the eigenfunctions z_alpha are normalized according to the conventions in,
  e.g., Owen (2009), Lovelace (2008), etc.
- Arbitrary rescalings of z_alpha rescale S_alpha and hence S.
- This module does not automatically normalize zU[alpha]. The caller is
  responsible for providing appropriately normalized eigenfunctions or for
  rescaling zOmega_integrals before calling Salpha_and_magnitude_from_zOmega.

Near-zero and fallback behavior:

- This module provides algebraic expressions for nominal and fallback
  spin-vector constructions. Any near-zero logic and selection between
  nominal and fallback is implemented in the NRPy-generated C code.

Surface gridfunctions (module-local, to avoid name collisions):

- SE_qDD[A][B]:
    Induced 2-metric q_AB on the surface.
- SE_qDD_dD[A][B][C]:
    First angular derivatives of SE_qDD; generated by NRPy C codegen.
- SE_qDD_dDD[A][B][C][D]:
    Second angular derivatives of SE_qDD; generated by NRPy C codegen.
- SE_XB[B]:
    X_B = e_B^i K_ij s^j on the surface.
- SE_XB_dD[B][A]:
    Angular derivatives of X_B; generated by NRPy C codegen.
- SE_zeta:
    Scalar eigenfunction z; user-provided gridfunction.
- SE_zeta_dD[A], SE_zeta_dDD[A][B]:
    First and second derivatives of SE_zeta; generated by NRPy C codegen.
- SE_y_aux:
    Auxiliary scalar y for eigenproblem; user-provided gridfunction.
- SE_y_aux_dD[A], SE_y_aux_dDD[A][B]:
    First and second derivatives of SE_y_aux; generated by NRPy C codegen.
- SE_flux_densityU[A]:
    Surface flux density for div(R grad z), defined as
    sqrt(q) * R * q^{AB} * partial_B z.
- SE_flux_densityU_dD[A][C]:
    Angular derivatives of SE_flux_densityU; generated by NRPy C codegen.

Inputs expected to already exist in BHaHAHA (on-surface samples):

- hh, hh_dD[A]:
    Surface radius h and its angular derivatives.
- gammaDD[i][j]:
    3-metric gamma_ij in spherical basis (r, theta, phi), evaluated at r=h(theta, phi).
- KDD[i][j]:
    Extrinsic curvature K_ij in the same basis, on the surface.
- sU[i]:
    Unit outward normal s^i in the same basis, on the surface.
- zU[alpha]:
    Three scalar modes z_alpha, used for zOmega integrals. They must be
    normalized externally if the resulting S is to be physically meaningful.

Everything else below is constructed symbolically within this module.
"""

from typing import Any, Dict, Iterable, List, Optional, cast

import sympy as sp

import nrpy.indexedexp as ixp
import nrpy.reference_metric as refmetric


def _sympify_int(x: int) -> sp.Integer:
    """
    Safely convert an integer-like input to a SymPy Integer.

    :param x: Integer-like input value.
    :return: SymPy Integer representation of the input.
    """
    return cast(sp.Integer, sp.Integer(int(sp.Integer(x))))


class SpECTRESpinEstimateClass:
    """
    Construct Omega-based quasilocal spin diagnostics on a deformed sphere.

    This class provides symbolic expressions for:
    - The induced 2-metric and associated geometric quantities on a closed
      2-surface defined by r = h(theta, phi).
    - The surface Ricci scalar R.
    - The spin function Omega = eps^{AB} * nabla_A X_B with
      X_B = e_B^i * K_ij * s^j.
    - Fluxes and Laplacians needed for eigenfunction-based spin measurements.
    - Helper routines to assemble spin vectors from precomputed integrals.

    All constructions assume:
    - Spherical coordinates with surface parameterized by (theta, phi).
    - Input tensors already evaluated on the surface in the (r, theta, phi) basis.
    """

    def __init__(
        self,
        CoordSystem: str = "Spherical",
        enable_rfm_precompute: bool = False,
        orientation_sign: int = +1,
    ):
        """
        Initialize the quasilocal spin estimator for a given configuration.

        :param CoordSystem: Coordinate system name; must be "Spherical".
        :param enable_rfm_precompute: Whether to use reference-metric
            precomputation variants; defaults to False.
        :param orientation_sign: Orientation for the 2D Levi-Civita tensor,
            either +1 or -1. This controls the sign convention for Omega and
            thus the spin direction.

        :raises ValueError: If CoordSystem is not "Spherical".
        :raises ValueError: If orientation_sign is not +1 or -1.
        """
        if CoordSystem != "Spherical":
            raise ValueError(
                f"Unsupported CoordSystem '{CoordSystem}'. Currently, only 'Spherical' is supported."
            )
        if int(orientation_sign) not in (+1, -1):
            raise ValueError("orientation_sign must be +1 or -1.")

        self.CoordSystem = CoordSystem
        self._orientation_sign = _sympify_int(orientation_sign)

        self._rfm = refmetric.reference_metric[
            (
                f"{self.CoordSystem}_rfm_precompute"
                if enable_rfm_precompute
                else self.CoordSystem
            )
        ]
        theta = self._rfm.xx[1]
        phi = self._rfm.xx[2]

        # Horizon shape and derivatives
        self._h = sp.Symbol("hh", real=True)
        self._h_dD = ixp.declarerank1("hh_dD", dimension=2)

        # Metric, extrinsic curvature, unit normal, and eigenmodes zU[alpha]
        self._gammaDD = ixp.declarerank2("gammaDD", symmetry="sym01", dimension=3)
        self._KDD = ixp.declarerank2("KDD", symmetry="sym01", dimension=3)
        self._sU = ixp.declarerank1("sU", dimension=3)
        self._zU = ixp.declarerank1("zU", dimension=3)

        # Tangent vectors e_A^i in (r, theta, phi) basis:
        # e_theta^i = (partial_theta h, 1, 0)
        # e_phi^i   = (partial_phi h, 0, 1)
        self._eADU: List[List[sp.Expr]] = [
            [sp.sympify(0) for _ in range(3)] for __ in range(2)
        ]
        self._eADU[0][0] = self._h_dD[0]
        self._eADU[0][1] = sp.sympify(1)
        self._eADU[0][2] = sp.sympify(0)
        self._eADU[1][0] = self._h_dD[1]
        self._eADU[1][1] = sp.sympify(0)
        self._eADU[1][2] = sp.sympify(1)

        # Induced 2-metric q_AB = gamma_ij e_A^i e_B^j
        self._SE_qDD = ixp.declarerank2("SE_qDD", symmetry="sym01", dimension=2)
        self._SE_qDD_expr = ixp.zerorank2(dimension=2)
        for A in range(2):
            for B in range(2):
                val = sp.sympify(0)
                for i in range(3):
                    for j in range(3):
                        val += self._eADU[A][i] * self._eADU[B][j] * self._gammaDD[i][j]
                self._SE_qDD_expr[A][B] = val

        # First and second derivatives of q_AB (to be provided by codegen)
        self._SE_qDD_dD = ixp.declarerank3("SE_qDD_dD", dimension=2)
        self._SE_qDD_dDD = ixp.declarerank4(
            "SE_qDD_dDD", symmetry="sym01_sym23", dimension=2
        )

        # Inverse 2-metric and sqrt(det q)
        self._SE_qUU, self._detq2 = ixp.symm_matrix_inverter2x2(self._SE_qDD_expr)
        self._sqrtq = sp.sqrt(self._detq2)

        # 2D Levi-Civita tensor with configurable orientation
        self._eps2UU = ixp.zerorank2(dimension=2)
        self._eps2UU[0][1] = self._orientation_sign / self._sqrtq
        self._eps2UU[1][0] = -self._orientation_sign / self._sqrtq

        # X_B = e_B^i K_ij s^j
        self._SE_XB = ixp.declarerank1("SE_XB", dimension=2)
        self._SE_XB_expr = [sp.sympify(0), sp.sympify(0)]
        for B in range(2):
            val = sp.sympify(0)
            for i in range(3):
                for j in range(3):
                    val += self._eADU[B][i] * self._KDD[i][j] * self._sU[j]
            self._SE_XB_expr[B] = val

        # Derivatives of X_B (to be provided by codegen)
        self._SE_XB_dD = ixp.declarerank2("SE_XB_dD", dimension=2)

        # Scalars for eigenproblem (z and y_aux fields)
        self._SE_zeta = sp.Symbol("SE_zeta", real=True)
        self._SE_zeta_dD = ixp.declarerank1("SE_zeta_dD", dimension=2)
        self._SE_zeta_dDD = ixp.declarerank2(
            "SE_zeta_dDD", symmetry="sym01", dimension=2
        )

        self._SE_y_aux = sp.Symbol("SE_y_aux", real=True)
        self._SE_y_aux_dD = ixp.declarerank1("SE_y_aux_dD", dimension=2)
        self._SE_y_aux_dDD = ixp.declarerank2(
            "SE_y_aux_dDD", symmetry="sym01", dimension=2
        )

        # Placeholders; will be defined in _build_intrinsic_ops_and_omega.
        self._R: sp.Expr = sp.sympify(0)
        self._Omega_base: sp.Expr = sp.sympify(0)
        self._Omega: sp.Expr = sp.sympify(0)

        # Build intrinsic connection, R, Omega, and Laplacians
        self._build_intrinsic_ops_and_omega()

        # Default MeasurementFrame coordinates:
        # Assume a physical Cartesian embedding of (h, theta, phi):
        # x = h sin(theta) cos(phi), y = h sin(theta) sin(phi), z = h cos(theta).
        # This is valid only if the MeasurementFrame coincides with that embedding.
        # Users may override via set_measurement_frame_coords().
        self._xMeasU = [
            self._h * sp.sin(theta) * sp.cos(phi),
            self._h * sp.sin(theta) * sp.sin(phi),
            self._h * sp.cos(theta),
        ]

        # Integrands depending on x, R, Omega
        self._x_times_R_integrand = [self._xMeasU[i] * self._R for i in range(3)]
        self._xOmega_momentU = [self._xMeasU[i] * self._Omega for i in range(3)]
        self._zOmegaU = [self._zU[a] * self._Omega for a in range(3)]

        # Flux for div(R grad z): F^A = sqrt(q) * R * q^{AB} * z_,B
        self._SE_flux_densityU = ixp.declarerank1("SE_flux_densityU", dimension=2)
        self._SE_flux_densityU_expr = [sp.sympify(0), sp.sympify(0)]
        for A in range(2):
            tmp = sp.sympify(0)
            for B in range(2):
                tmp += self._sqrtq * self._R * self._SE_qUU[A][B] * self._SE_zeta_dD[B]
            self._SE_flux_densityU_expr[A] = tmp

        # Derivatives of flux; used for div(R grad z)
        self._SE_flux_densityU_dD = ixp.declarerank2("SE_flux_densityU_dD", dimension=2)

        flux_div = sp.sympify(0)
        for A in range(2):
            flux_div += self._SE_flux_densityU_dD[A][A]
        # div_R_grad_z = (1/sqrt(q)) * partial_A ( sqrt(q) R q^{AB} z_,B )
        self._div_R_grad_z = flux_div / self._sqrtq

    # ========================= Public API =========================

    def set_measurement_frame_coords(self, xMeasU: List[sp.Expr]) -> None:
        """
        Set MeasurementFrame coordinates x^i(theta, phi) on the surface.

        The MeasurementFrame provides the coordinates used to define
        the spin vector components S^i.

        Requirements:
        - xMeasU must have length 3.
        - Each entry must depend only on (theta, phi, h(theta, phi)) and must
          not depend explicitly on the ambient radial coordinate xx[0].
          Any radial dependence must come through h.

        :param xMeasU: List of three SymPy expressions for the measurement
            frame coordinates evaluated on the surface.
        :raises ValueError: If xMeasU does not have length 3.
        :raises ValueError: If any expression depends explicitly on xx[0].
        """
        if len(xMeasU) != 3:
            raise ValueError("xMeasU must have length 3.")
        rr = self._rfm.xx[0]
        for expr in xMeasU:
            if rr in sp.sympify(expr).free_symbols:
                raise ValueError(
                    "MeasurementFrame coordinate depends explicitly on xx[0]. "
                    "Provide on-surface expressions using (theta, phi, h) only."
                )
        self._xMeasU = list(xMeasU)
        self._x_times_R_integrand = [self._xMeasU[i] * self._R for i in range(3)]
        self._xOmega_momentU = [self._xMeasU[i] * self._Omega for i in range(3)]

    def set_orientation_sign(self, sign: int) -> None:
        """
        Set the orientation sign for the 2D Levi-Civita tensor and update Omega.

        An orientation sign of +1 corresponds to eps^{theta,phi} = +1 / sqrt(q).
        Flipping the sign flips Omega and thus the sign of the resulting spin.

        :param sign: Orientation sign, +1 or -1.
        :raises ValueError: If sign is not +1 or -1.
        """
        if int(sign) not in (+1, -1):
            raise ValueError("orientation_sign must be +1 or -1.")
        self._orientation_sign = _sympify_int(sign)

        # Update epsilon^{AB}
        self._eps2UU[0][1] = self._orientation_sign / self._sqrtq
        self._eps2UU[1][0] = -self._orientation_sign / self._sqrtq

        # Recompute Omega = eps^{AB} * nabla_A X_B using updated eps^{AB}
        omega_sum = sp.sympify(0)
        for A in range(2):
            for B in range(2):
                covXB = self._SE_XB_dD[B][A]
                for C in range(2):
                    covXB += -self._GammaU2DD[C][A][B] * self._SE_XB[C]
                omega_sum += self._eps2UU[A][B] * covXB
        self._Omega = omega_sum

        # Update dependent integrands
        self._xOmega_momentU = [self._xMeasU[i] * self._Omega for i in range(3)]
        self._zOmegaU = [self._zU[a] * self._Omega for a in range(3)]

    def get_public_integrands(self) -> Dict[str, Any]:
        """
        Return symbolic integrands and densities for use in C code generation.

        The returned dictionary includes:
        - "area_integrand": Constant 1, used with sqrt(q) for area.
        - "area_density": sqrt(q).
        - "ricci_scalar": Surface Ricci scalar R.
        - "spin_function": Spin function Omega.
        - "abs_omega_integrand": abs(Omega).
        - "measurement_frame_xU": MeasurementFrame coordinates x^i.
        - "x_times_R_integrand": x^i * R.
        - "xOmega_momentU": x^i * Omega.
        - "zOmegaU": z_alpha * Omega (for each provided mode).
        - "laplacian_of_z": Surface Laplacian of SE_zeta.
        - "laplacian_of_y": Surface Laplacian of SE_y_aux.
        - "div_R_grad_z": Divergence of R * grad(z) divided by sqrt(q).
        - "gauss_bonnet_integrand": Alias of R for Gaussâ€“Bonnet checks.
        - "omega_constraint_integrand": Alias of Omega for consistency checks.

        :return: Dictionary mapping descriptive names to SymPy expressions or
            lists of expressions.
        """
        out: Dict[str, Any] = {}
        out["area_integrand"] = sp.Integer(1)
        out["area_density"] = self._sqrtq
        out["ricci_scalar"] = self._R
        out["spin_function"] = self._Omega
        out["abs_omega_integrand"] = sp.Abs(self._Omega)
        out["measurement_frame_xU"] = self._xMeasU
        out["x_times_R_integrand"] = self._x_times_R_integrand
        out["xOmega_momentU"] = self._xOmega_momentU
        out["zOmegaU"] = self._zOmegaU
        out["laplacian_of_z"] = self._laplacian_of_z
        out["laplacian_of_y"] = self._laplacian_of_y
        out["div_R_grad_z"] = self._div_R_grad_z
        out["gauss_bonnet_integrand"] = self._R
        out["omega_constraint_integrand"] = self._Omega
        return out

    def get_gridfunction_assignments(self) -> Dict[sp.Symbol, sp.Expr]:
        """
        Return mapping of gridfunctions to their defining expressions.

        The returned assignments must be emitted by NRPy C code generation
        before derivative operators (producing _dD, _dDD) are applied.

        The caller is responsible for:
        - Generating all required derivatives of the registered gridfunctions.
        - Ensuring a consistent finite-difference stencil across all uses.

        :return: Dictionary mapping SymPy symbols (gridfunctions) to their
            defining SymPy expressions.
        """
        assignments: Dict[sp.Symbol, sp.Expr] = {}

        # Induced metric q_AB
        for A in range(2):
            for B in range(2):
                assignments[cast(sp.Symbol, self._SE_qDD[A][B])] = self._SE_qDD_expr[A][
                    B
                ]

        # X_B
        for B in range(2):
            assignments[cast(sp.Symbol, self._SE_XB[B])] = self._SE_XB_expr[B]

        # Flux density for div(R grad z)
        for A in range(2):
            assignments[cast(sp.Symbol, self._SE_flux_densityU[A])] = (
                self._SE_flux_densityU_expr[A]
            )

        return assignments

    def reduce_centroids_and_direction(self, sums: Dict[str, Any]) -> Dict[str, Any]:
        """
        Reduce pre-accumulated surface integrals to centroids and direction data.

        Expected entries in sums (all area-weighted integrals over the surface):

        - "A":
            Integral of dA over the surface.
        - Either:
            * "XU" as an iterable with three components: integral of x^i dA,
              or:
            * "XU0", "XU1", "XU2" as separate entries.
        - "R0":
            Integral of R dA.
        - Either:
            * "XRU" as iterable: integral of x^i R dA,
              or:
            * "XRU0", "XRU1", "XRU2" separately.
        - "O0":
            Integral of Omega dA.
        - Either:
            * "XOU" as iterable: integral of x^i Omega dA,
              or:
            * "XOU0", "XOU1", "XOU2" separately.

        The routine computes:
        - x0U:
            Area-weighted centroid x0^i = (integral x^i dA) / A.
        - xRcorrU:
            Ricci-shifted centroid correction:
            x_R^i = (integral x^i R dA - x0^i * integral R dA) / (8 * pi).
        - IU:
            Direction integrals:
            I^i = integral x^i Omega dA - (x0^i + x_R^i) * integral Omega dA.
        - normI:
            Euclidean norm of I^i.
        - nU:
            Unit direction I^i / normI (no conditioning; handled in generated C).

        :param sums: Dictionary of accumulated integrals as described above.
        :return: Dictionary with keys "x0U", "xRcorrU", "IU", "normI", and "nU".
        """
        if "XU" in sums:
            A = sums["A"]
            XU = list(cast(Iterable[Any], sums["XU"]))
            R0 = sums["R0"]
            XRU = list(cast(Iterable[Any], sums["XRU"]))
            O0 = sums["O0"]
            XOU = list(cast(Iterable[Any], sums["XOU"]))
        else:
            A = sums["A"]
            XU = [sums["XU0"], sums["XU1"], sums["XU2"]]
            R0 = sums["R0"]
            XRU = [sums["XRU0"], sums["XRU1"], sums["XRU2"]]
            O0 = sums["O0"]
            XOU = [sums["XOU0"], sums["XOU1"], sums["XOU2"]]

        # Area-weighted centroid
        x0U = [XU[i] / A for i in range(3)]

        # Ricci moment: x_R^i = (1/(8*pi)) * (int x^i R dA - x0^i * int R dA)
        xRcorrU = [(XRU[i] - x0U[i] * R0) / (8 * sp.pi) for i in range(3)]

        # Direction integral:
        # I^i = int x^i Omega dA - (x0^i + x_R^i) * int Omega dA
        IU = [XOU[i] - (x0U[i] + xRcorrU[i]) * O0 for i in range(3)]

        normI = sp.sqrt(IU[0] ** 2 + IU[1] ** 2 + IU[2] ** 2)

        # Unit vector (no conditioning; handled in generated C)
        nU = [IU[i] / normI for i in range(3)]

        return {
            "x0U": x0U,
            "xRcorrU": xRcorrU,
            "IU": IU,
            "normI": normI,
            "nU": nU,
        }

    def Salpha_and_magnitude_from_zOmega(
        self,
        zOmega_integrals: List[sp.Expr],
    ) -> Dict[str, Any]:
        """
        Compute S_alpha and the spin magnitude S from z_alpha * Omega integrals.

        Given:
        - zOmega_integrals[alpha] = integral z_alpha * Omega dA for three modes
          alpha = 0, 1, 2,

        this routine computes:
        - S_alpha = (1 / (8 * pi)) * zOmega_integrals[alpha],
        - S = sqrt( sum_alpha S_alpha^2 ).

        Important:
        - This formula is valid only if the eigenfunctions z_alpha are normalized
          according to standard quasilocal spin conventions. Rescaling z_alpha
          rescales S_alpha and hence S.

        :param zOmega_integrals: List of three integrals:
            [integral z_0 Omega dA, integral z_1 Omega dA, integral z_2 Omega dA].
        :return: Dictionary with keys:
            - "SalphaU": List of three S_alpha components.
            - "S": Spin magnitude S.
        :raises ValueError: If zOmega_integrals does not contain exactly three
            entries.
        """
        if len(zOmega_integrals) != 3:
            raise ValueError("zOmega_integrals must have three entries.")
        salphaU = [zOmega_integrals[a] / (8 * sp.pi) for a in range(3)]
        S = sp.sqrt(salphaU[0] ** 2 + salphaU[1] ** 2 + salphaU[2] ** 2)
        return {"SalphaU": salphaU, "S": S}

    def magnitude_from_zOmega(self, zOmega_integrals: List[sp.Expr]) -> sp.Expr:
        """
        Compute the spin magnitude from z_alpha * Omega integrals.

        This convenience wrapper uses:
        S = ||zOmega_integrals|| / (8 * pi),
        with the same normalization caveats as
        Salpha_and_magnitude_from_zOmega.

        :param zOmega_integrals: List of three integrals:
            [integral z_0 Omega dA, integral z_1 Omega dA, integral z_2 Omega dA].
        :return: Spin magnitude S as a SymPy expression.
        :raises ValueError: If zOmega_integrals does not contain exactly three
            entries.
        """
        if len(zOmega_integrals) != 3:
            raise ValueError("zOmega_integrals must have three entries.")
        ssum = sp.sympify(0)
        for a in range(3):
            ssum += zOmega_integrals[a] ** 2
        return cast(sp.Expr, sp.sqrt(ssum) / (8 * sp.pi))

    def compute_spin_vectors_for_c(
        self,
        sums: Dict[str, Any],
        S: sp.Expr,
        zOmega_integrals: Optional[List[sp.Expr]] = None,
    ) -> Dict[str, Any]:
        """
        Construct algebraic nominal and fallback spin-vector expressions.

        This routine performs no near-zero or exact-zero conditioning.
        The generated C code is responsible for any near-zero checks and for
        selecting between nominal and fallback expressions.

        Returned expressions:
        - SU_nominal: S * I / ||I||
        - SU_fallback_zero: 0
        - If zOmega_integrals is provided:
            SalphaU = zOmega_integrals / (8*pi)
            Salpha_norm = ||SalphaU||
            SU_fallback_zalpha = S * SalphaU / Salpha_norm

        :param sums: Dictionary of precomputed surface integrals, as required
            by reduce_centroids_and_direction.
        :param S: Spin magnitude to be associated with the final vector.
        :param zOmega_integrals: Optional list of three integrals:
            [integral z_0 Omega dA, integral z_1 Omega dA, integral z_2 Omega dA].
        :return: Dictionary containing:
            - "SU_nominal": List of three components of S * I / ||I||.
            - "SU_fallback_zero": List of three zeros.
            - "SalphaU": List of three components (only if zOmega_integrals provided).
            - "Salpha_norm": Norm of SalphaU (only if zOmega_integrals provided).
            - "SU_fallback_zalpha": List of three components (only if provided).
            - "normI": Norm of I^i.
            - "x0U", "xRcorrU", "IU", "nU": As returned by
              reduce_centroids_and_direction.
        :raises ValueError: If zOmega_integrals is provided but does not contain
            exactly three entries.
        """
        red = self.reduce_centroids_and_direction(sums)
        nU = cast(List[sp.Expr], red["nU"])
        SU_nominal = [S * nU[i] for i in range(3)]

        SU_fallback_zero: List[sp.Expr] = [sp.sympify(0), sp.sympify(0), sp.sympify(0)]

        out: Dict[str, Any] = {
            "SU_nominal": SU_nominal,
            "SU_fallback_zero": SU_fallback_zero,
            "normI": red["normI"],
            "x0U": red["x0U"],
            "xRcorrU": red["xRcorrU"],
            "IU": red["IU"],
            "nU": red["nU"],
        }

        if zOmega_integrals is not None:
            if len(zOmega_integrals) != 3:
                raise ValueError("zOmega_integrals must have three entries.")
            SalphaU = [zOmega_integrals[a] / (8 * sp.pi) for a in range(3)]
            Salpha_norm = sp.sqrt(SalphaU[0] ** 2 + SalphaU[1] ** 2 + SalphaU[2] ** 2)
            SU_fallback_zalpha = [S * SalphaU[i] / Salpha_norm for i in range(3)]
            out["SalphaU"] = SalphaU
            out["Salpha_norm"] = Salpha_norm
            out["SU_fallback_zalpha"] = SU_fallback_zalpha

        return out

    # ========================= Internals =========================

    def _build_intrinsic_ops_and_omega(self) -> None:
        """
        Build intrinsic geometric operators and the spin function Omega.

        This routine constructs:

        - Derivatives of the inverse 2-metric q^{AB}.
        - 2D Christoffel symbols Gamma^C_{AB}.
        - Derivatives of Gamma^C_{AB}.
        - The surface Ricci scalar R.
        - The spin function
          Omega = eps^{AB} * nabla_A X_B = eps^{AB} * (partial_A X_B - Gamma^C_{AB} X_C).
        - Laplacians of SE_zeta and SE_y_aux:
          Delta f = q^{AB} * (partial_A partial_B f - Gamma^C_{AB} partial_C f).

        All first- and second-derivative symbols (*_dD, *_dDD) appearing in
        these constructions are assumed to be provided by NRPy-generated code
        using consistent finite-difference stencils.
        """
        # Derivatives of q^{AB}: qUU_dD[A][B][C] = partial_C q^{AB}
        self._SE_qUUdD = ixp.zerorank3(dimension=2)
        for A in range(2):
            for B in range(2):
                for C in range(2):
                    tmp = sp.sympify(0)
                    for E in range(2):
                        for F in range(2):
                            tmp += (
                                -self._SE_qUU[A][E]
                                * self._SE_qUU[B][F]
                                * self._SE_qDD_dD[E][F][C]
                            )
                    self._SE_qUUdD[A][B][C] = tmp

        # 2D Christoffel symbols Gamma^C_{AB}
        self._GammaU2DD = ixp.zerorank3(dimension=2)
        for C in range(2):
            for A in range(2):
                for B in range(2):
                    val = sp.sympify(0)
                    for D in range(2):
                        val += (
                            sp.Rational(1, 2)
                            * self._SE_qUU[C][D]
                            * (
                                self._SE_qDD_dD[B][D][A]
                                + self._SE_qDD_dD[A][D][B]
                                - self._SE_qDD_dD[A][B][D]
                            )
                        )
                    self._GammaU2DD[C][A][B] = val

        # Derivatives of Gamma^C_{AB}: Gamma^C_{AB,E}
        self._GammaU2DD_dD = ixp.zerorank4(dimension=2)
        for E in range(2):
            for C in range(2):
                for A in range(2):
                    for B in range(2):
                        term = sp.sympify(0)
                        for D in range(2):
                            bracket = (
                                self._SE_qDD_dD[B][D][A]
                                + self._SE_qDD_dD[A][D][B]
                                - self._SE_qDD_dD[A][B][D]
                            )
                            d_bracket = (
                                self._SE_qDD_dDD[B][D][A][E]
                                + self._SE_qDD_dDD[A][D][B][E]
                                - self._SE_qDD_dDD[A][B][D][E]
                            )
                            term += sp.Rational(1, 2) * (
                                self._SE_qUUdD[C][D][E] * bracket
                                + self._SE_qUU[C][D] * d_bracket
                            )
                        self._GammaU2DD_dD[C][A][B][E] = term

        # Build parts for Ricci scalar:
        # R = q^{AB} ( partial_C Gamma^C_{AB} - partial_B Gamma^C_{AC}
        #              + Gamma^C_{AB} Gamma^D_{CD} - Gamma^C_{AD} Gamma^D_{BC} )
        dC_GammaCAB = ixp.zerorank2(dimension=2)
        dB_GammaCAC = ixp.zerorank2(dimension=2)
        for A in range(2):
            for B in range(2):
                dC_GammaCAB[A][B] = cast(
                    sp.Expr, sum(self._GammaU2DD_dD[C][A][B][C] for C in range(2))
                )
                dB_GammaCAC[A][B] = cast(
                    sp.Expr, sum(self._GammaU2DD_dD[C][A][C][B] for C in range(2))
                )

        GammaCAB_GammaDCD = ixp.zerorank2(dimension=2)
        GammaCAD_GammaDBC = ixp.zerorank2(dimension=2)
        for A in range(2):
            for B in range(2):
                g1 = sp.sympify(0)
                g2 = sp.sympify(0)
                for C in range(2):
                    for D in range(2):
                        g1 += self._GammaU2DD[C][A][B] * self._GammaU2DD[D][C][D]
                        g2 += self._GammaU2DD[C][A][D] * self._GammaU2DD[D][B][C]
                GammaCAB_GammaDCD[A][B] = g1
                GammaCAD_GammaDBC[A][B] = g2

        # Ricci scalar R
        self._R = sp.sympify(0)
        for A in range(2):
            for B in range(2):
                self._R += self._SE_qUU[A][B] * (
                    dC_GammaCAB[A][B]
                    - dB_GammaCAC[A][B]
                    + GammaCAB_GammaDCD[A][B]
                    - GammaCAD_GammaDBC[A][B]
                )

        # Spin function Omega = eps^{AB} * nabla_A X_B
        omega_sum = sp.sympify(0)
        for A in range(2):
            for B in range(2):
                covXB = self._SE_XB_dD[B][A]
                for C in range(2):
                    covXB += -self._GammaU2DD[C][A][B] * self._SE_XB[C]
                omega_sum += self._eps2UU[A][B] * covXB
        self._Omega_base = omega_sum
        self._Omega = self._Omega_base

        # Laplacians of zeta and y_aux:
        # Delta f = q^{AB} * ( partial_A partial_B f - Gamma^C_{AB} partial_C f )
        self._laplacian_of_z = sp.sympify(0)
        self._laplacian_of_y = sp.sympify(0)
        for A in range(2):
            for B in range(2):
                term_z = self._SE_zeta_dDD[A][B]
                term_y = self._SE_y_aux_dDD[A][B]
                for C in range(2):
                    term_z += -self._GammaU2DD[C][A][B] * self._SE_zeta_dD[C]
                    term_y += -self._GammaU2DD[C][A][B] * self._SE_y_aux_dD[C]
                self._laplacian_of_z += self._SE_qUU[A][B] * term_z
                self._laplacian_of_y += self._SE_qUU[A][B] * term_y


class SpECTRESpinEstimateClass_dict(Dict[str, SpECTRESpinEstimateClass]):
    """
    Dictionary-like accessor for SpECTRESpinEstimateClass instances.

    Supported keys:
    - "Spherical":
        Spherical coordinates without reference-metric precomputation.
    - "Spherical_rfm_precompute":
        Spherical coordinates with reference-metric precomputation enabled.

    The key determines which reference-metric configuration is used to set up
    coordinate symbols; the resulting symbolic expressions are otherwise
    identical.
    """

    def __getitem__(self, key: str) -> SpECTRESpinEstimateClass:
        """
        Retrieve a SpECTRESpinEstimateClass instance for the given key.

        If an instance for the requested key does not exist yet, it is created.

        :param key: Configuration key; must be "Spherical" or
            "Spherical_rfm_precompute".
        :return: Corresponding SpECTRESpinEstimateClass instance.
        :raises KeyError: If an unsupported key is requested.
        """
        if key not in self:
            if key == "Spherical":
                enable_rfm_precompute = False
            elif key == "Spherical_rfm_precompute":
                enable_rfm_precompute = True
            else:
                raise KeyError(
                    f"Unsupported key: '{key}'. Supported keys are "
                    "'Spherical' and 'Spherical_rfm_precompute'."
                )

            print(f"Setting up SpECTRESpinEstimateClass[{key}]...")
            self.__setitem__(
                key,
                SpECTRESpinEstimateClass(
                    CoordSystem="Spherical",
                    enable_rfm_precompute=enable_rfm_precompute,
                    orientation_sign=+1,
                ),
            )
        return dict.__getitem__(self, key)

    def __setitem__(self, key: str, value: SpECTRESpinEstimateClass) -> None:
        """
        Store a SpECTRESpinEstimateClass instance under the given key.

        Only "Spherical" and "Spherical_rfm_precompute" are allowed.

        :param key: Configuration key.
        :param value: Instance to store.
        :raises KeyError: If an unsupported key is provided.
        """
        if key not in ["Spherical", "Spherical_rfm_precompute"]:
            raise KeyError(
                f"Unsupported key: '{key}'. Supported keys are "
                "'Spherical' and 'Spherical_rfm_precompute'."
            )
        dict.__setitem__(self, key, value)


# Public handle for external use
SpECTRESpinEstimate = SpECTRESpinEstimateClass_dict()

if __name__ == "__main__":
    import doctest
    import os
    import sys

    import nrpy.validate_expressions.validate_expressions as ve

    # Run doctests
    results = doctest.testmod()
    if results.failed > 0:
        print(f"Doctest failed: {results.failed} of {results.attempted} test(s)")
        sys.exit(1)
    print(f"Doctest passed: All {results.attempted} test(s) passed")

    # Sanity validation of expressions for both factory options
    for validation_key in ["Spherical", "Spherical_rfm_precompute"]:
        omega_calc = SpECTRESpinEstimate[validation_key]
        results_dict = ve.process_dictionary_of_expressions(
            omega_calc.__dict__,
            fixed_mpfs_for_free_symbols=True,
        )
        ve.compare_or_generate_trusted_results(
            os.path.abspath(__file__),
            os.getcwd(),
            f"{os.path.splitext(os.path.basename(__file__))[0]}_{validation_key}",
            results_dict,
        )
