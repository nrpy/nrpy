# equations/general_relativity/bhahaha/SpECTRESpinEstimate.py
r"""
Ω-based quasilocal spin diagnostics on r = h(θ, φ), constructed intrinsically.
All expressions are built on-surface; no r→h substitutions.

ASSUMPTIONS AND SCOPE (IMPORTANT):

- CoordSystem MUST be "Spherical".
- The ambient coordinates (xx[0],xx[1],xx[2]) are (r, θ, φ).
- The tensors gammaDD[i][j], KDD[i][j], and sU[i] are given in this same
  spherical coordinate basis.
- The surface is parameterized by (θ, φ) with r = h(θ, φ).
- Under these assumptions, the tangent vectors e_A^i defined below are
  consistent with e_A^i = ∂x^i/∂ξ^A in the (r, θ, φ) basis.

If your data are in a different coordinate basis (e.g. Cartesian), you MUST:
- Transform gammaDD, KDD, sU into the spherical basis before using this class, or
- Implement a different embedding/tangent construction consistent with
  your chosen basis.

EIGENFUNCTION NORMALIZATION (CRITICAL):

- The quasilocal spin magnitude S computed from z_α and Ω assumes that the
  eigenfunctions z_α are normalized according to the conventions in
  Owen (2009), Lovelace (2008), etc. In particular, arbitrary rescalings
  of z_α will rescale S_α and hence S.

- This class does NOT automatically normalize zU[α]. The caller is responsible
  for supplying Kerr-normalized eigenfunctions or for rescaling zOmega_integrals
  appropriately before calling Salpha_and_magnitude_from_zOmega().

- The fallback "zalpha" spin direction in near-zero cases is constructed from
  the vector S_α itself, which is scale-invariant under common rescalings of
  z_α and thus robust to normalization, but the absolute magnitude S is not.

SURFACE GRIDFUNCTIONS (module-local, to avoid name collisions)
---------------------------------------------------------------------------
- SE_qDD[A][B]           : induced 2-metric on the surface (A,B ∈ {0:θ, 1:φ})
- SE_qDD_dD[A][B][C]     : ∂_C SE_qDD[A][B]           (generated by c_codegen)
- SE_qDD_dDD[A][B][C][D] : ∂_D∂_C SE_qDD[A][B]        (generated by c_codegen)
- SE_XB[B]               : X_B = e_B^i K_ij s^j
- SE_XB_dD[B][A]         : ∂_A X_B                   (generated by c_codegen)
- SE_zeta                : scalar z                  (user-provided gridfunction)
- SE_zeta_dD[A], SE_zeta_dDD[A][B]                   (generated by c_codegen)
- SE_y_aux               : scalar y (aux for Δy)     (user-provided gridfunction)
- SE_y_aux_dD[A], SE_y_aux_dDD[A][B]                 (generated by c_codegen)
- SE_flux_densityU[A]    : √q R q^{AB} z_,B
- SE_flux_densityU_dD[A][C]                          (generated by c_codegen)

INPUTS EXPECTED TO ALREADY EXIST IN BHaHAHA (on-surface samples)
----------------------------------------------------------------
- hh, hh_dD[A]           : surface radius and angular derivatives
- gammaDD[i][j]          : 3-metric γ_ij (in spherical basis, at r=h(θ,φ))
- KDD[i][j]              : extrinsic curvature (same basis, on the surface)
- sU[i]                  : unit outward normal (same basis, on the surface)
- zU[α]                  : three scalar modes z_α (for zΩ integrals);
                           MUST be normalized externally as per quasilocal
                           spin conventions if S is to be physically correct.

Everything else below is constructed symbolically here.
"""

from typing import Any, Dict, Iterable, List, Optional, Tuple, Union, cast

import sympy as sp

import nrpy.indexedexp as ixp
import nrpy.reference_metric as refmetric


def _sympify_int(x: int) -> sp.Integer:
    return sp.Integer(int(sp.Integer(x)))


class SpECTRESpinEstimateClass:
    def __init__(
        self,
        CoordSystem: str = "Spherical",
        enable_rfm_precompute: bool = False,
        orientation_sign: int = +1,
    ):
        # Enforce spherical coordinate system as described in the docstring.
        if CoordSystem != "Spherical":
            raise ValueError(
                "SpECTRESpinEstimateClass currently supports only CoordSystem='Spherical'. "
                "gammaDD, KDD, and sU must be given in the (r,theta,phi) basis."
            )
        if int(orientation_sign) not in (+1, -1):
            raise ValueError("orientation_sign must be +1 or -1.")
        self.CoordSystem = CoordSystem
        self._orientation_sign = _sympify_int(orientation_sign)

        self._rfm = refmetric.reference_metric[
            (
                (self.CoordSystem + "_rfm_precompute")
                if enable_rfm_precompute
                else self.CoordSystem
            )
        ]
        theta = self._rfm.xx[1]
        phi = self._rfm.xx[2]

        # Horizon shape and derivatives
        self._h = sp.Symbol("hh", real=True)
        self._h_dD = ixp.declarerank1("hh_dD", dimension=2)

        # Metric, extrinsic curvature, unit normal, and eigenmodes zU[alpha]
        self._gammaDD = ixp.declarerank2("gammaDD", symmetry="sym01", dimension=3)
        self._KDD = ixp.declarerank2("KDD", symmetry="sym01", dimension=3)
        self._sU = ixp.declarerank1("sU", dimension=3)
        self._zU = ixp.declarerank1("zU", dimension=3)

        # Tangent vectors e_A^i in (r,theta,phi) basis:
        # e_theta^i = (∂_θ h, 1, 0)
        # e_phi^i   = (∂_φ h, 0, 1)
        # This is consistent ONLY if gammaDD, KDD, sU are in that same basis.
        self._eADU = [[sp.sympify(0) for _ in range(3)] for __ in range(2)]
        self._eADU[0][0] = self._h_dD[0]
        self._eADU[0][1] = 1
        self._eADU[0][2] = 0
        self._eADU[1][0] = self._h_dD[1]
        self._eADU[1][1] = 0
        self._eADU[1][2] = 1

        # Induced 2-metric q_AB = gamma_ij e_A^i e_B^j
        self._SE_qDD = ixp.declarerank2("SE_qDD", symmetry="sym01", dimension=2)
        self._SE_qDD_expr = ixp.zerorank2(dimension=2)
        for A in range(2):
            for B in range(2):
                val = sp.sympify(0)
                for i in range(3):
                    for j in range(3):
                        val += self._eADU[A][i] * self._eADU[B][j] * self._gammaDD[i][j]
                self._SE_qDD_expr[A][B] = val

        # First and second derivatives of q_AB to be filled by NRPy codegen
        self._SE_qDD_dD = ixp.declarerank3("SE_qDD_dD", dimension=2)
        self._SE_qDD_dDD = ixp.declarerank4(
            "SE_qDD_dDD", symmetry="sym01_sym23", dimension=2
        )

        # Inverse 2-metric and sqrt(det q)
        self._SE_qUU, self._detq2 = ixp.symm_matrix_inverter2x2(self._SE_qDD_expr)
        self._sqrtq = sp.sqrt(self._detq2)

        # 2D Levi-Civita tensor with configurable orientation
        self._eps2UU = ixp.zerorank2(dimension=2)
        self._eps2UU[0][1] = self._orientation_sign / self._sqrtq
        self._eps2UU[1][0] = -self._orientation_sign / self._sqrtq

        # X_B = e_B^i K_ij s^j
        self._SE_XB = ixp.declarerank1("SE_XB", dimension=2)
        self._SE_XB_expr = [sp.sympify(0), sp.sympify(0)]
        for B in range(2):
            val = sp.sympify(0)
            for i in range(3):
                for j in range(3):
                    val += self._eADU[B][i] * self._KDD[i][j] * self._sU[j]
            self._SE_XB_expr[B] = val

        # Derivatives of X_B to be generated
        self._SE_XB_dD = ixp.declarerank2("SE_XB_dD", dimension=2)

        # Scalars for eigenproblem
        self._SE_zeta = sp.Symbol("SE_zeta", real=True)
        self._SE_zeta_dD = ixp.declarerank1("SE_zeta_dD", dimension=2)
        self._SE_zeta_dDD = ixp.declarerank2(
            "SE_zeta_dDD", symmetry="sym01", dimension=2
        )
        self._SE_y_aux = sp.Symbol("SE_y_aux", real=True)
        self._SE_y_aux_dD = ixp.declarerank1("SE_y_aux_dD", dimension=2)
        self._SE_y_aux_dDD = ixp.declarerank2(
            "SE_y_aux_dDD", symmetry="sym01", dimension=2
        )

        # Build intrinsic connection, R, Omega, Laplacians
        self._build_intrinsic_ops_and_omega()

        # Default MeasurementFrame coordinates:
        # Assume physical Cartesian embedding of the same spherical (h,theta,phi).
        # This is ONLY correct if MeasurementFrame coincides with that embedding.
        # For general use, override via set_measurement_frame_coords().
        self._xMeasU = [
            self._h * sp.sin(theta) * sp.cos(phi),
            self._h * sp.sin(theta) * sp.sin(phi),
            self._h * sp.cos(theta),
        ]

        # Integrands depending on x, R, Omega
        self._x_times_R_integrand = [self._xMeasU[i] * self._R for i in range(3)]
        self._xOmega_momentU = [self._xMeasU[i] * self._Omega for i in range(3)]
        self._zOmegaU = [self._zU[a] * self._Omega for a in range(3)]

        # Flux for div(R grad z): F^A = sqrt(q) R q^{AB} z_,B
        self._SE_flux_densityU = ixp.declarerank1("SE_flux_densityU", dimension=2)
        self._SE_flux_densityU_expr = [sp.sympify(0), sp.sympify(0)]
        for A in range(2):
            tmp = sp.sympify(0)
            for B in range(2):
                tmp += self._sqrtq * self._R * self._SE_qUU[A][B] * self._SE_zeta_dD[B]
            self._SE_flux_densityU_expr[A] = tmp

        # Derivatives of flux; used for div(R grad z)
        self._SE_flux_densityU_dD = ixp.declarerank2("SE_flux_densityU_dD", dimension=2)

        flux_div = sp.sympify(0)
        for A in range(2):
            flux_div += self._SE_flux_densityU_dD[A][A]
        # div_R_grad_z = (1/sqrt(q)) * ∂_A ( sqrt(q) R q^{AB} z_,B )
        self._div_R_grad_z = flux_div / self._sqrtq

    # ========================= Public API =========================

    def set_measurement_frame_coords(self, xMeasU: List[sp.Expr]) -> None:
        """
        Set MeasurementFrame coordinates x^i(θ,φ) on the surface.

        Requirements:
        - xMeasU has length 3.
        - Each expression depends only on (θ, φ, h(θ,φ)) and NOT explicitly on
          the ambient radial coordinate xx[0]; r-dependence must come through h.
        """
        if len(xMeasU) != 3:
            raise ValueError("xMeasU must have length 3.")
        rr = self._rfm.xx[0]
        for expr in xMeasU:
            if rr in sp.sympify(expr).free_symbols:
                raise ValueError(
                    "MeasurementFrame coordinate depends on ambient radial xx[0]. "
                    "Provide on-surface expressions using (θ, φ, h) only."
                )
        self._xMeasU = list(xMeasU)
        self._x_times_R_integrand = [self._xMeasU[i] * self._R for i in range(3)]
        self._xOmega_momentU = [self._xMeasU[i] * self._Omega for i in range(3)]

    def set_orientation_sign(self, sign: int) -> None:
        """
        Set orientation_sign = +1 or -1 and update epsilon^{AB} and Omega.

        orientation_sign = +1 corresponds to ε^{θφ} = +1/√q.
        Flipping the sign flips Omega and hence S^i.
        """
        if int(sign) not in (+1, -1):
            raise ValueError("orientation_sign must be +1 or -1.")
        self._orientation_sign = _sympify_int(sign)

        # Update epsilon^{AB}
        self._eps2UU[0][1] = self._orientation_sign / self._sqrtq
        self._eps2UU[1][0] = -self._orientation_sign / self._sqrtq

        # Recompute Omega from current eps2UU
        Omega_sum = sp.sympify(0)
        for A in range(2):
            for B in range(2):
                covXB = self._SE_XB_dD[B][A]
                for C in range(2):
                    covXB += -self._GammaU2DD[C][A][B] * self._SE_XB[C]
                Omega_sum += self._eps2UU[A][B] * covXB
        self._Omega = Omega_sum

        # Update dependent integrands
        self._xOmega_momentU = [self._xMeasU[i] * self._Omega for i in range(3)]
        self._zOmegaU = [self._zU[a] * self._Omega for a in range(3)]

    def get_public_integrands(self) -> Dict[str, object]:
        """
        Return symbolic integrands and densities for use in C codegen.

        Conventions:
        - To integrate f over the surface, use:
            sum_{a,b} f_{ab} * area_element_{ab} * w_a w_b
          where area_element = sqrt(q) * Δθ * Δφ.
        """
        out: Dict[str, object] = {}
        out["area_integrand"] = 1
        out["area_density"] = self._sqrtq
        out["ricci_scalar"] = self._R
        out["spin_function"] = self._Omega
        out["abs_omega_integrand"] = sp.Abs(self._Omega)
        out["measurement_frame_xU"] = self._xMeasU
        out["x_times_R_integrand"] = self._x_times_R_integrand
        out["xOmega_momentU"] = self._xOmega_momentU
        out["zOmegaU"] = self._zOmegaU
        out["laplacian_of_z"] = self._laplacian_of_z
        out["laplacian_of_y"] = self._laplacian_of_y
        out["div_R_grad_z"] = self._div_R_grad_z
        out["gauss_bonnet_integrand"] = self._R
        out["omega_constraint_integrand"] = self._Omega
        return out

    def get_gridfunction_assignments(self) -> Dict[sp.Symbol, sp.Expr]:
        """
        Returns mapping of gridfunctions to their defining expressions.

        These assignments must be emitted by NRPy c_codegen before derivative
        operators are applied to generate the _dD/_dDD symbols.

        The calling code must ensure that all derivatives (_dD, _dDD) used here
        are computed with a consistent finite-difference stencil.
        """
        assignments: Dict[sp.Symbol, sp.Expr] = {}

        # Induced metric
        for A in range(2):
            for B in range(2):
                assignments[self._SE_qDD[A][B]] = self._SE_qDD_expr[A][B]

        # X_B
        for B in range(2):
            assignments[self._SE_XB[B]] = self._SE_XB_expr[B]

        # Flux density for div(R grad z)
        for A in range(2):
            assignments[self._SE_flux_densityU[A]] = self._SE_flux_densityU_expr[A]

        return assignments

    def reduce_centroids_and_direction(
        self, sums: Dict[str, object]
    ) -> Dict[str, object]:
        """
        Reduce pre-accumulated integrals to:
        - x0U: area-weighted centroid (x0^i = (∮ x^i dA)/A)
        - xRcorrU: Ricci moment shift x_R^i
        - IU: direction integral pieces
        - normI: ||I||
        - nU: unit direction I^i / ||I||

        Expected entries in 'sums' (all must be area-weighted integrals):
        - A   = ∮ dA
        - XU0,XU1,XU2 or XU[] = ∮ x^i dA
        - R0  = ∮ R dA
        - XRU0,XRU1,XRU2 or XRU[] = ∮ x^i R dA
        - O0  = ∮ Ω dA
        - XOU0,XOU1,XOU2 or XOU[] = ∮ x^i Ω dA

        NOTE: This routine assumes correct weighting; the caller must ensure
        that sums include area_element * weights.
        """
        if "XU" in sums:
            A = sums["A"]
            XU = list(cast(Iterable[Any], sums["XU"]))
            R0 = sums["R0"]
            XRU = list(cast(Iterable[Any], sums["XRU"]))
            O0 = sums["O0"]
            XOU = list(cast(Iterable[Any], sums["XOU"]))
        else:
            A = sums["A"]
            XU = [sums["XU0"], sums["XU1"], sums["XU2"]]
            R0 = sums["R0"]
            XRU = [sums["XRU0"], sums["XRU1"], sums["XRU2"]]
            O0 = sums["O0"]
            XOU = [sums["XOU0"], sums["XOU1"], sums["XOU2"]]

        # Area-weighted centroid
        x0U = [XU[i] / A for i in range(3)]

        # Ricci moment: x_R^i = (1/(8π)) ∮ (x^i - x0^i) R dA
        xRcorrU = [(XRU[i] - x0U[i] * R0) / (8 * sp.pi) for i in range(3)]

        # Direction integral using algebraic form:
        # I^i = ∮ x^i Ω dA - (x0^i + x_R^i) ∮ Ω dA
        IU = [XOU[i] - (x0U[i] + xRcorrU[i]) * O0 for i in range(3)]

        normI = sp.sqrt(IU[0] ** 2 + IU[1] ** 2 + IU[2] ** 2)

        # Unit vector; exact zero check retained (codegen users may add tolerance)
        nU = [
            sp.Piecewise((0, sp.Eq(normI, 0)), (IU[i] / normI, True)) for i in range(3)
        ]

        return {
            "x0U": x0U,
            "xRcorrU": xRcorrU,
            "IU": IU,
            "normI": normI,
            "nU": nU,
        }

    def near_zero_policy(
        self,
        A: sp.Expr,
        normI: sp.Expr,
        integral_abs_Omega: sp.Expr,
        eps: Union[float, sp.Expr],
    ) -> Dict[str, sp.Expr]:
        """
        Near-zero ||I|| policy trigger:
        trigger = [ ||I|| <= eps * R_char * ∮|Ω| dA ],
        where R_char = sqrt(A / (4π)).
        """
        R_char = sp.sqrt(A / (4 * sp.pi))
        return {"trigger": sp.Le(normI, sp.sympify(eps) * R_char * integral_abs_Omega)}

    def Salpha_and_magnitude_from_zOmega(
        self,
        zOmega_integrals: List[sp.Expr],
    ) -> Dict[str, object]:
        """
        Given zOmega_integrals[α] = ∮ z_α Ω dA (with properly normalized z_α),
        compute:
        - S_α = (1/(8π)) zOmega_integrals[α]
        - S = ||S_α||

        IMPORTANT:
        - This formula is correct only if z_α are normalized according to the
          conventions in the cited quasilocal spin literature.
        - If z_α are rescaled, S_α and S rescale accordingly.
        """
        if len(zOmega_integrals) != 3:
            raise ValueError("zOmega_integrals must have three entries.")
        SalphaU = [zOmega_integrals[a] / (8 * sp.pi) for a in range(3)]
        S = sp.sqrt(SalphaU[0] ** 2 + SalphaU[1] ** 2 + SalphaU[2] ** 2)
        return {"SalphaU": SalphaU, "S": S}

    def magnitude_from_zOmega(self, zOmega_integrals: List[sp.Expr]) -> sp.Expr:
        """
        Convenience wrapper: S = ||zOmega_integrals|| / (8π),
        same normalization caveats as Salpha_and_magnitude_from_zOmega().
        """
        if len(zOmega_integrals) != 3:
            raise ValueError("zOmega_integrals must have three entries.")
        ssum = sp.sympify(0)
        for a in range(3):
            ssum += zOmega_integrals[a] ** 2
        return sp.sqrt(ssum) / (8 * sp.pi)

    def compute_spin_vector(
        self,
        sums: Dict[str, object],
        S: sp.Expr,
        eps: Union[float, sp.Expr],
        fallback_choice: str = "zero",
        zOmega_integrals: Optional[List[sp.Expr]] = None,
    ) -> Dict[str, object]:
        """
        Compute spin vector S^i given:
        - 'sums': dictionary of precomputed surface integrals (area-weighted).
        - S: spin magnitude (e.g., from Salpha_and_magnitude_from_zOmega()).
        - eps: tolerance parameter for near-zero policy.
        - fallback_choice:
            "zero"   : if near-zero, return S^i = 0.
            "zalpha" : if near-zero and zOmega_integrals provided, use direction
                       from Salpha (see below).

        Fallback "zalpha" behavior (FIXED from previous version):
        - If triggered and zOmega_integrals are provided:
            * Compute S_α = zOmega_integrals[α] / (8π).
            * Form vector Salpha = (S_1, S_2, S_3).
            * If ||Salpha|| > 0, set fallback direction n_fallback^i =
              Salpha^i / ||Salpha||, and S^i = S * n_fallback^i.
            * This uses the principal eigenfunction combination direction and
              is invariant under common rescalings of z_α.
        - We no longer snap to coordinate axes; that behavior was unphysical.
        """
        red = self.reduce_centroids_and_direction(sums)
        Oabs = sums.get(
            "Oabs",
            sp.Symbol("integral_abs_Omega", real=True, nonnegative=True),
        )
        trigger = self.near_zero_policy(sums["A"], red["normI"], Oabs, eps)["trigger"]

        nU = cast(List[sp.Expr], red["nU"])
        nominal_SU = [S * nU[i] for i in range(3)]

        if fallback_choice not in ("zero", "zalpha"):
            raise ValueError("fallback_choice must be one of {'zero','zalpha'}.")

        # Default fallback: zero vector
        fallback_SU = [sp.sympify(0), sp.sympify(0), sp.sympify(0)]

        if (
            fallback_choice == "zalpha"
            and zOmega_integrals is not None
            and len(zOmega_integrals) == 3
        ):
            # Construct Salpha and its norm
            Salpha = [zOmega_integrals[a] / (8 * sp.pi) for a in range(3)]
            Salpha_norm = sp.sqrt(Salpha[0] ** 2 + Salpha[1] ** 2 + Salpha[2] ** 2)

            # If Salpha_norm != 0, use its direction as fallback axis
            # S_fallback^i = S * Salpha^i / ||Salpha||
            for i in range(3):
                fallback_SU[i] = sp.Piecewise(
                    (0, sp.Eq(Salpha_norm, 0)),
                    (S * Salpha[i] / Salpha_norm, True),
                )

        # Select between fallback and nominal based on near-zero trigger
        SU = [
            sp.Piecewise((fallback_SU[i], trigger), (nominal_SU[i], True))
            for i in range(3)
        ]

        out: Dict[str, object] = {
            "SU": SU,
            "near_zero_trigger": trigger,
            "normI": red["normI"],
        }
        out.update({k: red[k] for k in ("x0U", "xRcorrU", "IU", "nU")})
        return out

    # ========================= Internals =========================

    def _build_intrinsic_ops_and_omega(self) -> None:
        """
        Build intrinsic geometric operators on the 2-surface:
        - q^{AB} derivatives
        - 2D Christoffel symbols Γ^C_{AB}
        - Ricci scalar R
        - Spin function Ω = ε^{AB} ∇_A X_B
        - Laplacians of SE_zeta and SE_y_aux

        All derivatives SE_*_dD and SE_*_dDD are to be generated by NRPy
        using consistent finite-difference stencils.
        """
        # Derivatives of q^{AB}: qUU_dD[A][B][C] = ∂_C q^{AB}
        self._SE_qUUdD = ixp.zerorank3(dimension=2)
        for A in range(2):
            for B in range(2):
                for C in range(2):
                    tmp = sp.sympify(0)
                    for E in range(2):
                        for F in range(2):
                            tmp += (
                                -self._SE_qUU[A][E]
                                * self._SE_qUU[B][F]
                                * self._SE_qDD_dD[E][F][C]
                            )
                    self._SE_qUUdD[A][B][C] = tmp

        # 2D Christoffel symbols Γ^C_{AB}
        self._GammaU2DD = ixp.zerorank3(dimension=2)
        for C in range(2):
            for A in range(2):
                for B in range(2):
                    val = sp.sympify(0)
                    for D in range(2):
                        val += (
                            sp.Rational(1, 2)
                            * self._SE_qUU[C][D]
                            * (
                                self._SE_qDD_dD[B][D][A]
                                + self._SE_qDD_dD[A][D][B]
                                - self._SE_qDD_dD[A][B][D]
                            )
                        )
                    self._GammaU2DD[C][A][B] = val

        # Derivatives of Γ^C_{AB}: Γ^C_{AB,E}
        self._GammaU2DD_dD = ixp.zerorank4(dimension=2)
        for E in range(2):
            for C in range(2):
                for A in range(2):
                    for B in range(2):
                        term = sp.sympify(0)
                        for D in range(2):
                            bracket = (
                                self._SE_qDD_dD[B][D][A]
                                + self._SE_qDD_dD[A][D][B]
                                - self._SE_qDD_dD[A][B][D]
                            )
                            d_bracket = (
                                self._SE_qDD_dDD[B][D][A][E]
                                + self._SE_qDD_dDD[A][D][B][E]
                                - self._SE_qDD_dDD[A][B][D][E]
                            )
                            term += sp.Rational(1, 2) * (
                                self._SE_qUUdD[C][D][E] * bracket
                                + self._SE_qUU[C][D] * d_bracket
                            )
                        self._GammaU2DD_dD[C][A][B][E] = term

        # Build pieces for Ricci scalar:
        # R = q^{AB} ( ∂_C Γ^C_{AB} - ∂_B Γ^C_{AC}
        #              + Γ^C_{AB} Γ^D_{CD} - Γ^C_{AD} Γ^D_{BC} )
        dC_GammaCAB = ixp.zerorank2(dimension=2)
        dB_GammaCAC = ixp.zerorank2(dimension=2)
        for A in range(2):
            for B in range(2):
                dC_GammaCAB[A][B] = sum(
                    self._GammaU2DD_dD[C][A][B][C] for C in range(2)
                )
                dB_GammaCAC[A][B] = sum(
                    self._GammaU2DD_dD[C][A][C][B] for C in range(2)
                )

        GammaCAB_GammaDCD = ixp.zerorank2(dimension=2)
        GammaCAD_GammaDBC = ixp.zerorank2(dimension=2)
        for A in range(2):
            for B in range(2):
                g1 = sp.sympify(0)
                g2 = sp.sympify(0)
                for C in range(2):
                    for D in range(2):
                        g1 += self._GammaU2DD[C][A][B] * self._GammaU2DD[D][C][D]
                        g2 += self._GammaU2DD[C][A][D] * self._GammaU2DD[D][B][C]
                GammaCAB_GammaDCD[A][B] = g1
                GammaCAD_GammaDBC[A][B] = g2

        # Ricci scalar R
        self._R = sp.sympify(0)
        for A in range(2):
            for B in range(2):
                self._R += self._SE_qUU[A][B] * (
                    dC_GammaCAB[A][B]
                    - dB_GammaCAC[A][B]
                    + GammaCAB_GammaDCD[A][B]
                    - GammaCAD_GammaDBC[A][B]
                )

        # Spin function Ω = ε^{AB} ∇_A X_B, with ∇_A X_B = ∂_A X_B - Γ^C_{AB} X_C
        Omega_sum = sp.sympify(0)
        for A in range(2):
            for B in range(2):
                covXB = self._SE_XB_dD[B][A]
                for C in range(2):
                    covXB += -self._GammaU2DD[C][A][B] * self._SE_XB[C]
                Omega_sum += self._eps2UU[A][B] * covXB
        self._Omega_base = Omega_sum
        self._Omega = self._Omega_base

        # Laplacians of zeta and y_aux: Δf = q^{AB}(∂_A∂_B f - Γ^C_{AB} ∂_C f)
        self._laplacian_of_z = sp.sympify(0)
        self._laplacian_of_y = sp.sympify(0)
        for A in range(2):
            for B in range(2):
                term_z = self._SE_zeta_dDD[A][B]
                term_y = self._SE_y_aux_dDD[A][B]
                for C in range(2):
                    term_z += -self._GammaU2DD[C][A][B] * self._SE_zeta_dD[C]
                    term_y += -self._GammaU2DD[C][A][B] * self._SE_y_aux_dD[C]
                self._laplacian_of_z += self._SE_qUU[A][B] * term_z
                self._laplacian_of_y += self._SE_qUU[A][B] * term_y

    # =========================================================================
    # Dict-style cached factory
    # =========================================================================


class SpECTRESpinEstimateClass_dict(Dict[str, SpECTRESpinEstimateClass]):
    r"""
    Dictionary-like accessor for :class:`SpECTRESpinEstimateClass` instances.

    Keys
    ----
    * ``"Spherical"`` → reference metric without precompute.
    * ``"Spherical_rfm_precompute"`` → reference metric with precompute enabled.

    Notes
    -----
    The key only alters which ``rfm`` entry provides coordinate symbols; the
    resulting symbolic expressions are otherwise identical.
    """

    def __getitem__(self, key: str) -> SpECTRESpinEstimateClass:
        if key not in self:
            if key == "Spherical":
                enable_rfm_precompute = False
            elif key == "Spherical_rfm_precompute":
                enable_rfm_precompute = True
            else:
                raise KeyError(
                    "Supported keys are 'Spherical' and 'Spherical_rfm_precompute'."
                )
            print(f"Setting up SpECTRESpinEstimateClass[{key}]...")
            self.__setitem__(
                key,
                SpECTRESpinEstimateClass(
                    CoordSystem="Spherical",
                    enable_rfm_precompute=enable_rfm_precompute,
                    orientation_sign=+1,  # default convention ε^{θφ}=+1/√q
                ),
            )
        return dict.__getitem__(self, key)

    def __setitem__(self, key: str, value: SpECTRESpinEstimateClass) -> None:
        if key not in ["Spherical", "Spherical_rfm_precompute"]:
            raise KeyError(
                "Supported keys are 'Spherical' and 'Spherical_rfm_precompute'."
            )
        dict.__setitem__(self, key, value)


# Public handle
SpECTRESpinEstimate = SpECTRESpinEstimateClass_dict()

if __name__ == "__main__":
    import doctest
    import os
    import sys

    import nrpy.validate_expressions.validate_expressions as ve

    results = doctest.testmod()
    if results.failed > 0:
        print(f"Doctest failed: {results.failed} of {results.attempted} test(s)")
        sys.exit(1)
    else:
        print(f"Doctest passed: All {results.attempted} test(s) passed")

    # Sanity validation of expressions for both factory options
    for validation_key in ["Spherical", "Spherical_rfm_precompute"]:
        omega_calc = SpECTRESpinEstimate[validation_key]
        results_dict = ve.process_dictionary_of_expressions(
            omega_calc.__dict__, fixed_mpfs_for_free_symbols=True
        )
        ve.compare_or_generate_trusted_results(
            os.path.abspath(__file__),
            os.getcwd(),
            f"{os.path.splitext(os.path.basename(__file__))[0]}_{validation_key}",
            results_dict,
        )
