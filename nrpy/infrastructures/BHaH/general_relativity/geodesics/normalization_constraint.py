"""
Register C function for computing the normalization constraint of the state vector.

This module registers the 'normalization_constraint_{PARTICLE}' C function.
It computes the scalar invariant C = g_munu v^mu v^nu, where v^mu is the
4-vector (4-velocity or 4-momentum) contained in the state vector f.

Particle Support:
- Massive: f[8], v^mu = u^mu (4-velocity). Expected C = -1.
- Photon: f[9], v^mu = p^mu (4-momentum). Expected C = 0.

It generates a preamble to unpack the full 4-vector from the state vector f
(specifically f[4]..f[7]) into the local symbolic names (vU0..vU3).

Author: Dalton J. Moone
"""

import logging
import sys

import sympy as sp

import nrpy.c_codegen as ccg
import nrpy.c_function as cfc

# [Fix 1] Removed unused 'List' import


def normalization_constraint(norm_expr: sp.Expr, PARTICLE: str) -> None:
    """
    Generate and register the C function to compute the normalization constraint.

    :param norm_expr: The SymPy expression for the contraction g_munu v^mu v^nu.
    :param PARTICLE: The type of particle ("massive" or "photon").
                          Determines array size and naming convention.
    :raises ValueError: If PARTICLE is not "massive" or "photon".
    """
    # Step 1: Specific setup based on particle type
    if PARTICLE == "massive":
        array_size = 8
        vec_desc = "4-velocity u^mu"
        expected_val = "-1.0"
    elif PARTICLE == "photon":
        array_size = 9
        vec_desc = "4-momentum p^mu"
        expected_val = "0.0"
    else:
        raise ValueError(f"Unsupported PARTICLE: {PARTICLE}")

    # Step 2: Define C function metadata
    includes = ["BHaH_defines.h"]
    # The name is now just based on the particle type, not the spacetime
    name = f"normalization_constraint_{PARTICLE}"

    desc = f"""@brief Computes the normalization constraint of the 4-vector.

        Evaluates the scalar invariant:
            C = g_munu v^mu v^nu
        where v^mu corresponds to the {vec_desc} stored in the state array.

        Expected Value: {expected_val}

        Input:
            metric: The metric tensor components at the current location.
            f[{array_size}]: The state vector.
                  f[4] -> v^0 (time component)
                  f[5] -> v^1 (x component)
                  f[6] -> v^2 (y component)
                  f[7] -> v^3 (z component)
        Output:
            norm_out: The computed value of the constraint."""

    params = (
        "const metric_struct *restrict metric, "
        f"const double f[{array_size}], "
        "double *restrict norm_out"
    )

    # Step 3: Generate C body
    print(f" -> Generating C worker function: {name}...")

    # 3a. Generate the Math Body (using CSE)
    # The expression uses symbols vU0..vU3 (generated by ixp.declarerank1("vU"))
    body_math = ccg.c_codegen(
        [norm_expr],
        ["*norm_out"],
        enable_cse=True,
        verbose=False,
        include_braces=False,
    )

    # 3b. Generate the Dynamic Preamble
    preamble_lines = [f"// Unpack {vec_desc} components from f[4]..f[7]"]

    # Map f indices to the symbolic names expected by norm_expr (vU0..vU3)
    # Note: Indices 4-7 are consistent for both massive (8 elements) and photon (9 elements)
    preamble_lines.append("const double vU0 = f[4];")
    preamble_lines.append("const double vU1 = f[5];")
    preamble_lines.append("const double vU2 = f[6];")
    preamble_lines.append("const double vU3 = f[7];")
    preamble_lines.append("")

    preamble = "\n  ".join(preamble_lines)

    # Combine preamble and math
    full_body = preamble + body_math

    # Step 4: Register the C function
    cfc.register_CFunction(
        includes=includes,
        desc=desc,
        name=name,
        params=params,
        include_CodeParameters_h=False,
        body=full_body,
    )
    print(f"    ... {name}() registration complete.")


if __name__ == "__main__":
    import os

    # Ensure local modules can be imported
    sys.path.append(os.getcwd())

    try:
        from nrpy.equations.general_relativity.geodesics.geodesics import (
            Geodesic_Equations,
        )
    except ImportError as e:
        print(f"Error: Could not import required modules: {e}")
        sys.exit(1)

    # Configure logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("TestNormCheckAnalytic")

    # --- Configuration ---
    # We still need a valid key to grab the symbolic expression from Geodesic_Equations,
    # even though the final C function name won't include the spacetime.
    SPACETIME = "KerrSchild_Cartesian"
    PARTICLE = "photon"
    # ---------------------

    GEO_KEY = f"{SPACETIME}_{PARTICLE}"

    logger.info(
        "Test: Generating normalization_constraint C-code for %s (%s)...",
        SPACETIME,
        PARTICLE,
    )

    try:
        # 1. Acquire Symbolic Data
        logger.info(" -> Acquiring symbolic normalization constraint...")
        geodesic_data = Geodesic_Equations[GEO_KEY]
        # [Fix 2] Renamed variable to avoid shadowing function argument
        test_norm_expr = geodesic_data.norm_constraint_expr

        if test_norm_expr is None:
            raise ValueError(f"norm_constraint_expr is None for key {GEO_KEY}")

        # 2. Run the Generator
        # Note: We pass PARTICLE here to handle array sizing and naming.
        # Spacetime name is no longer passed.
        logger.info(" -> Calling normalization_constraint()...")
        normalization_constraint(test_norm_expr, PARTICLE)

        # 3. Validation
        # Construct expected name to verify registration
        # [Fix 3] Renamed variable to avoid shadowing local variable in function
        test_suffix = "photon" if PARTICLE == "photon" else "massive"
        cfunc_name = f"normalization_constraint_{test_suffix}"

        if cfunc_name not in cfc.CFunction_dict:
            raise RuntimeError(
                f"FAIL: '{cfunc_name}' was not registered in cfc.CFunction_dict."
            )
        logger.info(" -> PASS: '%s' function registered successfully.", cfunc_name)

        # 4. Output Files
        filename = f"{cfunc_name}.c"
        cfunc = cfc.CFunction_dict[cfunc_name]
        with open(filename, "w", encoding="utf-8") as f:
            f.write(cfunc.full_function)
        logger.info(" -> Written to %s", filename)

    except Exception as e:  # pylint: disable=broad-exception-caught
        logger.error(" -> FAIL: normalization_constraint test failed with error: %s", e)
        import traceback

        traceback.print_exc()
        sys.exit(1)
