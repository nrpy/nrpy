"""
Construct BHaH_gpu_defines from data registered to griddata_commondata, CodeParameters, and NRPyParameters.

Author: Samuel D. Tootle
        sdtootle **at** gmail **dot** com
"""

import sys
from pathlib import Path
from typing import Any, Dict, Union

import nrpy.grid as gri
import nrpy.params as par
from nrpy.helpers.generic import clang_format

# region Module-level Constants
# Centralize constants to improve maintainability and avoid magic strings.

# Dictionary keys for variable properties
_TYPE = "type"
_ARRAY_SIZE = "array_size"
_COMMENT = "comment"

# Filenames
_BHAH_DEVICE_DEFINES_H = "BHaH_device_defines.h"
_BHAH_GLOBAL_DEVICE_DEFINES_H = "BHaH_global_device_defines.h"
_BHAH_CUDA_GLOBAL_INIT_H = "BHaH_CUDA_global_init.h"

# NRPy+ parameter keys
_DEVICE_THREAD_MACROS_KEY = "DEVICE_THREAD_MACROS"

# Shared knowledge: List of __constant__ arrays that must be explicitly copied to the device.
_CONSTANT_ARRAYS_TO_COPY = [
    "d_evol_gf_parity",
    "d_aux_gf_parity",
    "d_auxevol_gf_parity",
    "d_gridfunctions_wavespeed",
    "d_gridfunctions_f_infinity",
]

# Boilerplate C-code strings, used across multiple classes.
_FILE_BANNER = """// BHaH core header file, automatically generated from cuda.output_BHaH_defines_h,
//    DO NOT EDIT THIS FILE BY HAND."""

# This constant represents the exact r-string from the original code.
_CUDA_HELPERS_BLOCK = r"""
// CUDA Error checking macro only active if compiled with -DDEBUG
// Otherwise additional synchronization overhead will occur
#ifdef DEBUG
#define cudaCheckErrors(v, msg) \
    do { \
        cudaError_t __err = cudaGetLastError(); \
        if (__err != cudaSuccess) { \
            fprintf(stderr, "Fatal error: %s %s (%s at %s:%d)\n", \
                #v, msg, cudaGetErrorString(__err), \
                __FILE__, __LINE__); \
            fprintf(stderr, "*** FAILED - ABORTING\n"); \
            exit(1); \
        } \
    } while (0);
#else
#define cudaCheckErrors(v, msg)
#endif

#define BHAH_MEMCPY_HOST_TO_DEVICE(dest_ptr, src_ptr, sz) cudaMemcpy(dest_ptr, src_ptr, sz, cudaMemcpyHostToDevice);

"""
# endregion

# Populate global extras dictionary with default thread counts.
if _DEVICE_THREAD_MACROS_KEY not in par.glb_extras_dict:
    par.glb_extras_dict[_DEVICE_THREAD_MACROS_KEY] = {}
par.glb_extras_dict[_DEVICE_THREAD_MACROS_KEY].update(
    {
        "BHAH_THREADS_IN_X_DIR_DEFAULT": 32,
        "BHAH_THREADS_IN_Y_DIR_DEFAULT": 1,
        "BHAH_THREADS_IN_Z_DIR_DEFAULT": 1,
    }
)


def generate_declaration_str(
    decl_dict: Dict[str, Dict[str, str]], prefix: str = ""
) -> str:
    """
    Generate a block string of C-style header definitions.

    :param decl_dict: Dictionary of definitions. Each key is a variable name,
                      and the value is a dictionary with 'type',
                      'array_size' (optional), and 'comment' (optional).
    :param prefix: An optional prefix for each declaration (e.g., 'extern').
    :returns: A string containing formatted C declarations.
    """
    if not decl_dict:
        return ""

    prefix_with_space = f"{prefix} " if prefix else ""
    lines = []
    for var, properties in decl_dict.items():
        comment = properties.get(_COMMENT, "")
        array_suffix = (
            f"[{properties[_ARRAY_SIZE]}]" if properties.get(_ARRAY_SIZE) else ""
        )
        lines.append(
            f"{comment}{prefix_with_space}{properties[_TYPE]} {var}{array_suffix};\n"
        )

    return "".join(lines)


class CUDA_BHaH_device_defines_h:
    r"""
    Generate and write to file the BHaH_CUDA_defines.h file.

    :param project_dir: Location to write file to
    :param additional_declarations_dict: Dictionary storing additional declaration dictionaries
    :param additional_macros_str: Block string of additional macro definitions
    :param num_streams: Number of CUDA streams to use
    :param nghosts: Number of ghost zones for the FD stencil
    :param set_parity_on_aux: Flag to set parity on auxiliary variables. Default is False.
    :param set_parity_on_auxevol: Flag to set parity on auxevol variables. Default is False.

    >>> import nrpy.c_function as cfc
    >>> from nrpy.helpers.generic import validate_strings
    >>> cfc.CFunction_dict.clear()
    >>> project_dir = Path("/tmp", "tmp_BHaH_defines_h")
    >>> d = CUDA_BHaH_device_defines_h(project_dir)
    >>> d.generate_output_str()
    >>> generated_str = d.file_output_str
    >>> validation_desc = "CUDA_BHaH_device_defines_h"
    >>> validate_strings(generated_str, validation_desc, file_ext="cu")
    """

    def __init__(
        self,
        project_dir: str,
        additional_declarations_dict: Union[Dict[str, Any], None] = None,
        additional_macros_str: Union[str, None] = None,
        num_streams: int = 3,
        nghosts: Union[int, None] = None,
        set_parity_on_aux: bool = False,
        set_parity_on_auxevol: bool = False,
    ) -> None:
        # Step 1: Initialize attributes and create project directory.
        self.project_Path = Path(project_dir)
        self.project_Path.mkdir(parents=True, exist_ok=True)
        self.num_streams = num_streams
        self.additional_decl_dict = additional_declarations_dict
        self.additional_macros_str = additional_macros_str
        self.bhah_CUDA_defines_filename = _BHAH_DEVICE_DEFINES_H
        self.NGHOSTS = nghosts

        # Step 2: Prepare all string and dictionary components, mirroring the original.
        self.macro_str = f"""
// Standard macro definitions
// We include the macro definition NUM_STREAMS since it is used for calculations in various
// algorithms in addition to defining the streams array
#define NUM_STREAMS {self.num_streams}
"""
        standard_decl_dict = self._build_standard_declarations(
            set_parity_on_aux, set_parity_on_auxevol
        )
        self.combined_decl_dict = standard_decl_dict
        self.decl_str = "// Standard declarations\n" + generate_declaration_str(
            self.combined_decl_dict, prefix="extern"
        )

        # Step 3: Generate content and write file, preserving original's behavior.
        self.file_output_str = ""
        self.generate_output_str()
        self.write_to_file()

    def _build_standard_declarations(
        self, set_parity_on_aux: bool, set_parity_on_auxevol: bool
    ) -> Dict[str, Dict[str, str]]:
        """
        Construct the dictionary of standard C-style declarations.

        :param set_parity_on_aux: Flag to set parity on auxiliary variables.
        :param set_parity_on_auxevol: Flag to set parity on auxevol variables.
        :returns: A dictionary of standard C-style declarations.
        """
        standard_decl_dict: Dict[str, Dict[str, str]] = {
            "d_params": {
                _TYPE: "__constant__ params_struct",
                _ARRAY_SIZE: "NUM_STREAMS",
                _COMMENT: "// Device storage for grid parameters\n",
            },
            "d_commondata": {
                _TYPE: "__constant__ commondata_struct",
                _ARRAY_SIZE: "",
                _COMMENT: "// Device storage for commondata\n",
            },
            "streams": {
                _TYPE: "cudaStream_t",
                _ARRAY_SIZE: "NUM_STREAMS",
                _COMMENT: "",
            },
            "GPU_N_SMS": {_TYPE: "size_t", _ARRAY_SIZE: "", _COMMENT: ""},
        }
        (
            evol_list,
            aux_list,
            auxevol_list,
        ) = gri.BHaHGridFunction.gridfunction_lists()[0:3]

        if evol_list:
            standard_decl_dict["d_evol_gf_parity"] = {
                _TYPE: "__constant__ int8_t",
                _ARRAY_SIZE: str(len(evol_list)),
                _COMMENT: "// Device storage for evolved gridfunction parity\n",
            }
            standard_decl_dict["d_gridfunctions_wavespeed"] = {
                _TYPE: "__constant__ REAL",
                _ARRAY_SIZE: "NUM_EVOL_GFS",
                _COMMENT: "",
            }
            standard_decl_dict["d_gridfunctions_f_infinity"] = {
                _TYPE: "__constant__ REAL",
                _ARRAY_SIZE: "NUM_EVOL_GFS",
                _COMMENT: "",
            }
        if set_parity_on_aux and aux_list:
            standard_decl_dict["d_aux_gf_parity"] = {
                _TYPE: "__constant__ int8_t",
                _ARRAY_SIZE: str(len(aux_list)),
                _COMMENT: "// Device storage for aux gridfunction parity\n",
            }
        if set_parity_on_auxevol and auxevol_list:
            standard_decl_dict["d_auxevol_gf_parity"] = {
                _TYPE: "__constant__ int8_t",
                _ARRAY_SIZE: str(len(auxevol_list)),
                _COMMENT: "// Device storage for aux evolved gridfunction parity\n",
            }
        return standard_decl_dict

    def combine_declarations_dicts(self) -> None:
        """Add additional_decl_dict to combined_decl_dict."""
        if self.additional_decl_dict:
            self.combined_decl_dict.update(self.additional_decl_dict)

    def generate_output_str(self) -> None:
        """Generate the block output string, replicating original logic."""
        file_content = _FILE_BANNER + "\n\n"
        file_content += self.macro_str
        if self.additional_macros_str:
            file_content += "\n\n// Additional Macros\n" + self.additional_macros_str

        file_content += "\n\n" + self.decl_str

        if self.additional_decl_dict:
            file_content += "\n\n// Additional Declarations\n"
            file_content += generate_declaration_str(
                self.additional_decl_dict, prefix="extern"
            )
            self.combine_declarations_dicts()

        file_content += "\n\n" + _CUDA_HELPERS_BLOCK

        for k, thread_cnt in par.glb_extras_dict[_DEVICE_THREAD_MACROS_KEY].items():
            file_content += f"#define {k.upper()} {thread_cnt}\n"

        self.file_output_str = clang_format(file_content)

    def write_to_file(self) -> None:
        """Write file_output_str to header file."""
        bhah_gpu_defines_file = self.project_Path / self.bhah_CUDA_defines_filename
        with bhah_gpu_defines_file.open("w", encoding="utf-8") as file:
            file.write(self.file_output_str)


class BHaH_CUDA_global_init_h:
    r"""
    Generate and write to file the BHaH_CUDA_global_init.h file.

    :param project_dir: Location to write file to
    :param declarations_dict: Dictionary storing declaration dictionaries

    >>> project_dir = Path("/tmp", "tmp_BHaH_defines_h")
    >>> gpu_d = CUDA_BHaH_device_defines_h(project_dir)
    >>> gpu_init = BHaH_CUDA_global_init_h(project_dir,gpu_d.combined_decl_dict)
    >>> print(gpu_init.file_output_str)
    // BHaH core header file, automatically generated from cuda.output_BHaH_defines_h,
    //    DO NOT EDIT THIS FILE BY HAND.
    <BLANKLINE>
    // Initialize streams
    for (int i = 0; i < NUM_STREAMS; ++i) {
      cudaStreamCreate(&streams[i]);
    }
    """

    def __init__(
        self,
        project_dir: str,
        declarations_dict: Dict[str, Dict[str, str]],
    ) -> None:
        self.project_Path = Path(project_dir)
        self.project_Path.mkdir(parents=True, exist_ok=True)
        self.filename = _BHAH_CUDA_GLOBAL_INIT_H
        self.file_output_str = self._generate_file_content(declarations_dict)
        self.write_to_file()

    def _generate_file_content(
        self, declarations_dict: Dict[str, Dict[str, str]]
    ) -> str:
        """
        Assemble the complete content for the initialization file.

        :param declarations_dict: Dictionary storing all declaration dictionaries.
        :returns: A string containing the complete, formatted file content.
        """
        file_content = _FILE_BANNER + "\n\n"
        file_content += """
// Initialize streams
for(int i = 0; i < NUM_STREAMS; ++i) {
    cudaStreamCreate(&streams[i]);
}"""

        for const_ary in _CONSTANT_ARRAYS_TO_COPY:
            if const_ary in declarations_dict:
                properties = declarations_dict[const_ary]
                host_ary_name = const_ary.replace("d_", "")
                host_ary_type = properties[_TYPE].replace("__constant__", "").strip()
                file_content += f"""// Copy {host_ary_name} to device __constant__ memory
cudaMemcpyToSymbol({const_ary}, {host_ary_name}, {properties[_ARRAY_SIZE]} * sizeof({host_ary_type}));
cudaCheckErrors(copy, "Copy to {const_ary} failed");
"""
        return clang_format(file_content)

    def write_to_file(self) -> None:
        """Write file_output_str to header file."""
        output_file = self.project_Path / self.filename
        with output_file.open("w", encoding="utf-8") as file:
            file.write(self.file_output_str)


class BHaH_CUDA_global_defines_h:
    r"""
    Generate and write to file the BHaH_device_defines_h file.

    :param project_dir: Location to write file to
    :param declarations_dict: Dictionary storing declaration dictionaries

    >>> project_dir = Path("/tmp", "tmp_BHaH_defines_h")
    >>> gpu_d = CUDA_BHaH_device_defines_h(project_dir)
    >>> gpu_init = BHaH_CUDA_global_init_h(project_dir,gpu_d.combined_decl_dict)
    >>> print(gpu_init.file_output_str)
    // BHaH core header file, automatically generated from cuda.output_BHaH_defines_h,
    //    DO NOT EDIT THIS FILE BY HAND.
    <BLANKLINE>
    // Initialize streams
    for (int i = 0; i < NUM_STREAMS; ++i) {
      cudaStreamCreate(&streams[i]);
    }
    """

    def __init__(
        self,
        project_dir: str,
        declarations_dict: Dict[str, Dict[str, str]],
        **_: Any,
    ) -> None:
        self.project_Path = Path(project_dir)
        self.project_Path.mkdir(parents=True, exist_ok=True)
        self.filename = _BHAH_GLOBAL_DEVICE_DEFINES_H
        self.file_output_str = self._generate_file_content(declarations_dict)
        self.write_to_file()

    def _generate_file_content(
        self, declarations_dict: Dict[str, Dict[str, str]]
    ) -> str:
        """
        Assemble the complete content for the global definitions file.

        :param declarations_dict: Dictionary storing all declaration dictionaries.
        :returns: A string containing the complete, formatted file content.
        """
        file_content = f"""{_FILE_BANNER}\n\n
#ifndef __BHAH_GLOBAL_DEVICE_DEFINES_H__
#include "BHaH_defines.h"
"""
        file_content += generate_declaration_str(declarations_dict)
        file_content += "#endif // __BHAH_GLOBAL_DEVICE_DEFINES_H__\n\n"
        return clang_format(file_content)

    def write_to_file(self) -> None:
        """Write file_output_str to header file."""
        output_file = self.project_Path / self.filename
        with output_file.open("w", encoding="utf-8") as file:
            file.write(self.file_output_str)


def output_device_headers(
    project_dir: str,
    additional_declarations_dict: Union[Dict[str, Any], None] = None,
    additional_macros_str: Union[str, None] = None,
    num_streams: int = 3,
    nghosts: Union[int, None] = None,
    set_parity_on_aux: bool = False,
    set_parity_on_auxevol: bool = False,
) -> str:
    """
    Generate device specific header files.

    :param project_dir: Project directory
    :param additional_declarations_dict: Dictionary storing additional declaration dictionaries
    :param additional_macros_str: Block string of additional macro definitions
    :param num_streams: Number of CUDA streams to use
    :param nghosts: FD stencil radius
    :param set_parity_on_aux: Flag to set parity on auxiliary variables. Default is False.
    :param set_parity_on_auxevol: Flag to set parity on auxevol variables. Default is False.
    :returns: header filename
    """
    parallelization = par.parval_from_str("parallelization")
    if parallelization != "cuda":
        return ""

    gpu_defines = CUDA_BHaH_device_defines_h(
        project_dir,
        additional_declarations_dict=additional_declarations_dict,
        additional_macros_str=additional_macros_str,
        num_streams=num_streams,
        nghosts=nghosts,
        set_parity_on_aux=set_parity_on_aux,
        set_parity_on_auxevol=set_parity_on_auxevol,
    )

    BHaH_CUDA_global_defines_h(
        project_dir,
        gpu_defines.combined_decl_dict,
    )

    BHaH_CUDA_global_init_h(
        project_dir,
        gpu_defines.combined_decl_dict,
    )
    return gpu_defines.bhah_CUDA_defines_filename


if __name__ == "__main__":
    import doctest

    # The doctests require a CFunction_dict and a 'parallelization' parameter.
    # We set them up here to ensure the tests can run in a standalone context.
    try:
        import nrpy.c_function as cfc

        cfc.CFunction_dict.clear()
        par.set_parval_from_str("parallelization", "cuda")
    except (ImportError, NameError):
        # Handle cases where nrpy is not fully available in a minimal environment.
        print(
            "Warning: NRPy environment not fully available. Doctests may be affected."
        )

    results = doctest.testmod()

    if results.failed > 0:
        print(f"Doctest failed: {results.failed} of {results.attempted} test(s)")
        sys.exit(1)
    else:
        print(f"Doctest passed: All {results.attempted} test(s) passed")
