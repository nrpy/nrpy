"""
Register the C function for BHaHAHA quasi-local horizon diagnostics.
This function computes the quasi-local angular momentum (spin) and the
Christodoulou-Ruffini mass of an apparent horizon.

This module follows the BHaH/NRPy+ framework to generate a C function
`bah_diagnostics_quasi_local_mass_spin` that implements the isolated/dynamical
horizon formalism, specifically the "boost-fixed" coordinate spin vector from
Owen et al. (2018), arXiv:1708.07325.

The core algorithm involves:
1. Defining tangent vectors and the induced 2-metric on the horizon surface.
2. Calculating the rotational 1-form, 'omega_A', from the 3D metric and
   extrinsic curvature interpolated to the horizon surface.
3. Computing the curl of 'omega_A' to get 'Omega'
4. Integrating 'Omega' over the apparent horizon surface (with 3D components of the surface coordinates minus the centroid and Ricci ) to get
5. Integrating 'omega' times a rotation field generated by the spin vector over the
   horizon surface to find the magnitude of the dimensionful spin J.
6. Using the magnitude J and the irreducible mass M_irr (from the horizon area) to
   compute the Christodoulou-Ruffini mass M.

Author: Ralston Graves
ralstongraves **at** gmail **dot** com
"""

from inspect import currentframe as cfr
from types import FrameType as FT
from typing import List, Union, cast

import sympy as sp

import nrpy.c_codegen as ccg
import nrpy.c_function as cfc
import nrpy.grid as gri
import nrpy.helpers.parallel_codegen as pcg
import nrpy.indexedexp as ixp
from nrpy.equations.general_relativity.bhahaha.ExpansionFunctionTheta import (
    ExpansionFunctionTheta,
)
from nrpy.infrastructures.BHaH import griddata_commondata
from nrpy.infrastructures.BHaH.BHaHAHA import area


def register_CFunction_diagnostics_quasi_local_mass_spin(
    CoordSystem: str = "Spherical",
    enable_fd_functions: bool = False,
) -> Union[None, pcg.NRPyEnv_type]:
    """
    Register the C function for BHaHAHA quasi-local mass and spin diagnostics.

    :param CoordSystem: The coordinate system to use, defaults to "Spherical".
    :param enable_fd_functions: Whether to enable finite difference functions, defaults to False.
    :return: An NRPyEnv_type object if registration is successful, otherwise None.
    """
    if pcg.pcg_registration_phase():
        pcg.register_func_call(f"{__name__}.{cast(FT, cfr()).f_code.co_name}", locals())
        return None

    # Register new gridfunctions for the Poisson solve and integrand storage.
    # OMEGA_GF is the source term (curl of omega_A).
    # VARPI_GF is the scalar potential to be solved for.
    # J_INTEGRAND_GF stores the integrand for each spin component.
    gri.register_gridfunctions(
        ["OMEGA_GF", "VARPI_GF"], group="AUX", gf_array_name="aux_gfs"
    )
    gri.register_gridfunctions_for_single_rank1(
        "J_INTEGRAND_I", group="AUX", gf_array_name="aux_gfs"
    )

    # Register centroid coordinates from commondata.
    griddata_commondata.register_griddata_commondata(
        __name__,
        "bhahaha_diagnostics_struct *restrict bhahaha_diagnostics",
        "BHaHAHA diagnostics struct",
        is_commondata=True,
    )
    # Define symbolic representations of the centroid coordinates.
    x_centroid = sp.Symbol("bhahaha_diagnostics->x_centroid_wrt_coord_origin")
    y_centroid = sp.Symbol("bhahaha_diagnostics->y_centroid_wrt_coord_origin")
    z_centroid = sp.Symbol("bhahaha_diagnostics->z_centroid_wrt_coord_origin")
    centroid = [x_centroid, y_centroid, z_centroid]

    # Define horizon surface Cartesian components 'h'
    h = ixp.declarerank1("hh", dimension=3)

    # Use ExpansionFunctionTheta as it provides many necessary geometric quantities
    # derived from the BSSN variables interpolated to the AH surface.
    Th = ExpansionFunctionTheta[CoordSystem]
    rfm = Th.rfm
    gammaDD = Th.gammaDD
    gammaUU = Th.gammaUU
    KDD = Th.KDD
    trK = sp.Symbol("trK", real=True)
    alpha = sp.Symbol("alpha", real=True)

    # Step 1: Define tangent vectors and induced 2-metric on the horizon surface.
    # The surface coordinates are theta and phi (rfm.xx[1], rfm.xx[2]).
    # The embedding map is x^i(theta, phi) from rfm.xx_to_Cart.
    tangent_vectors = ixp.zerorank2(dimension=3)  # e_A^i = partial_A x^i
    for i in range(3):  # i = Cartesian component (x, y, z)
        for A in range(1, 3):  # A = surface component (theta, phi)
            tangent_vectors[i][A - 1] = sp.diff(rfm.xx_to_Cart[i], rfm.xx[A])

    # Induced 2-metric q_AB = g_ij e_A^i e_B^j
    q2DD = ixp.zerorank2(dimension=2)
    for A in range(2):
        for B in range(2):
            for i in range(3):
                for j in range(3):
                    q2DD[A][B] += gammaDD[i][j] * tangent_vectors[i][A] * tangent_vectors[j][B]

    q2UU, q2det = ixp.symm_matrix_inverter2x2(q2DD)

    # Step 2: Compute derivatives of the 2-metric and the 2D Christoffel symbols.
    q2DDdD = ixp.declarerank3("q2DDdD", symmetry="sym01", dimension=2)
    ChristoffelUDD = ixp.zerorank3(dimension=2)
    for A in range(2):
        for B in range(2):
            for C in range(2):
                for D in range(2):
                    ChristoffelUDD[A][B][C] += sp.Rational(1, 2) * q2UU[A][D] * (
                        q2DDdD[D][B][C] + q2DDdD[D][C][B] - q2DDdD[B][C][D]
                    )

    # Step 3: Compute the rotational 1-form, omega_A.
    # omega_A = (K_ij - K*g_ij) * e_A^i * s^j
    # from https://arxiv.org/pdf/1708.07325
    sU = Th.sU
    omegaD = ixp.zerorank1(dimension=2)
    for A in range(2):
        for i in range(3):
            for j in range(3):
                omegaD[A] += (KDD[i][j] - trK * gammaDD[i][j]) * tangent_vectors[i][A] * sU[j]

    # Step 4: Compute Omega = curl of omega_A
    # Omega = epsilon^{AB} D_A omega_B = (1/sqrt(q_det)) * (d_theta omega_phi - d_phi omega_theta)
    # Unable to find second equation anywhere else besides whitepaper,
    # might switch to covariant derivative form
    omegaD_dD = ixp.declarerank2("omegaD_dD", dimension=2)
    Omega = (1 / sp.sqrt(q2det)) * (omegaD_dD[1][0] - omegaD_dD[0][1])

    LeviCivitaSymbolDDD = ixp.LeviCivitaSymbol_dim3_rank3()


    # Step 5: Define the integrand for each spin component J_i.
    # J_i = (1/8pi) * Integral [ Omega * (x^i - x_0^i -x_R^i) ] dS
    # from https://arxiv.org/pdf/1708.07325

    R_integrand = ixp.zerorank1(dimension=3)
    J_integrand = ixp.zerorank1(dimension=3)

    for i in range(3):
        # Covariant derivative of a 1-form on the surface: D_A V_B = partial_A V_B - Gamma^C_{AB} V_C
        J_integrand[i] = Omega * (h[i] - centroid[i])

    # Step 7: Register the C function.
    includes = ["BHaH_defines.h", "BHaH_function_prototypes.h", "math.h"]
    desc = "BHaHAHA quasi-local diagnostics: compute quasi-local spin (J) and Christodoulou-Ruffini mass (M)."
    cfunc_type = "int"
    name = "bah_diagnostics_quasi_local_mass_spin"
    params = (
        "commondata_struct *restrict commondata, griddata_struct *restrict griddata"
    )

  # Will actually need two integrals, one for x_R^i (Ricci scalar across surface)
  # And one for the actual angular momentum vector J^i

    prefunc = r"""

  #pragma omp parallel for
  for (int i2 = NGHOSTS; i2 < params->Nxx2 + NGHOSTS; i2++) {
    for (int i1 = NGHOSTS; i1 < params->Nxx1 + NGHOSTS; i1++) {
      const int i0 = NGHOSTS;
      aux_gfs[IDX4(VARPI_GFGF, i0, i1, i2)] = aux_gfs[IDX4(OMEGA_GFGF, i0, i1, i2)];
    }
  }
}
"""

    body = r"""
  const int grid=0;
  const params_struct *restrict params = &griddata[grid].params;
  REAL *restrict aux_gfs = griddata[grid].gridfuncs.aux_gfs;
  const REAL *restrict auxevol_gfs = griddata[grid].gridfuncs.auxevol_gfs;
  const REAL *restrict in_gfs = griddata[grid].gridfuncs.y_n_gfs; // for hh
  REAL *restrict xx[3];
  for(int ww=0;ww<3;ww++) xx[ww] = griddata[grid].xx[ww];
#include "set_CodeParameters.h"

  // Step A: Compute the source term Omega = curl(omega_A) and store it in OMEGA_GF.
#pragma omp parallel for
  for (int i2 = NGHOSTS; i2 < params->Nxx2 + NGHOSTS; i2++) {
    for (int i1 = NGHOSTS; i1 < params->Nxx1 + NGHOSTS; i1++) {
      const int i0 = NGHOSTS; // Horizon is a 2D surface at a fixed radial slice for this evolution.
"""
    body += ccg.c_codegen(
        [Omega],
        [gri.BHaHGridFunction.access_gf("OMEGA_GF", gf_array_name="aux_gfs")],
        enable_fd_codegen=True, enable_fd_functions=enable_fd_functions,
    )
    body += r"""
    }
  }

  // Step B: Solve the Poisson equation D^2(varpi) = Omega for varpi.
  // The result is stored in VARPI_GF.
  solve_poisson_on_horizon(params, xx, aux_gfs);

  // Step C: Compute the integrand for each spin component J_i and store in J_INTEGRAND_IGF.
#pragma omp parallel for
  for (int i2 = NGHOSTS; i2 < params->Nxx2 + NGHOSTS; i2++) {
    for (int i1 = NGHOSTS; i1 < params->Nxx1 + NGHOSTS; i1++) {
      const int i0 = NGHOSTS;
      // Read varpi from the gridfunction array after the Poisson solve.
      const REAL varpi_gf = aux_gfs[IDX4(VARPI_GFGF, i0, i1, i2)];
"""
    body += ccg.c_codegen(
        J_integrand,
        [gri.BHaHGridFunction.access_gf(f"J_INTEGRAND_I{i}", gf_array_name="aux_gfs") for i in range(3)],
        enable_fd_codegen=True, enable_fd_functions=enable_fd_functions,
    )
    body += r"""
    }
  }

  // Step D: Compute the surface integrals to get the spin components J_i.
  const REAL *restrict weights;
  int weight_stencil_size;
  bah_diagnostics_integration_weights(params->Nxx1, params->Nxx2, &weights, &weight_stencil_size);

  REAL J_quasi_local[3] = {0.0, 0.0, 0.0};
  for (int i_comp = 0; i_comp < 3; i_comp++) {
    REAL sum_integrand = 0.0;
    #pragma omp parallel for reduction(+:sum_integrand)
    for (int i2 = NGHOSTS; i2 < params->Nxx2 + NGHOSTS; i2++) {
      const REAL weight2 = weights[(i2 - NGHOSTS) % weight_stencil_size];
      for (int i1 = NGHOSTS; i1 < params->Nxx1 + NGHOSTS; i1++) {
        const REAL weight1 = weights[(i1 - NGHOSTS) % weight_stencil_size];
        const int i0 = NGHOSTS;
        const REAL integrand = aux_gfs[IDX4(J_INTEGRAND_I0GF + i_comp, i0, i1, i2)];
"""
    body += ccg.c_codegen(
        [area.area3()],
        ["const REAL area_element"],
        enable_fd_codegen=True, enable_fd_functions=enable_fd_functions,
    )
    body += r"""
        sum_integrand += integrand * area_element * weight1 * weight2;
      }
    }
    J_quasi_local[i_comp] = (1.0 / (8.0 * M_PI)) * sum_integrand * params->dxx1 * params->dxx2;
  }

  // Step E: Finalize spin magnitude and mass calculations and store results.
  bhahaha_diagnostics_struct *restrict bhahaha_diags = commondata->bhahaha_diagnostics;

  const REAL J_mag_sq = J_quasi_local[0]*J_quasi_local[0] + J_quasi_local[1]*J_quasi_local[1] + J_quasi_local[2]*J_quasi_local[2];
  const REAL J_mag = sqrt(J_mag_sq);

  const REAL Area = bhahaha_diags->area;
  if (Area <= 1e-15) { return 1; /* Return non-zero for error */ }
  const REAL M_irr = sqrt(Area / (16.0 * M_PI));
  const REAL M_irr2 = M_irr * M_irr;
  if (M_irr2 <= 1e-15) { return 1; /* Return non-zero for error */ }
  const REAL M_sq = M_irr2 + J_mag_sq / (4.0 * M_irr2);
  const REAL M_quasi_local = sqrt(M_sq);

  // Store diagnostics in the commondata struct.
  bhahaha_diags->spin_chi_x_DH = J_quasi_local[0];
  bhahaha_diags->spin_chi_y_DH = J_quasi_local[1];
  bhahaha_diags->spin_chi_z_DH = J_quasi_local[2];
  // Note: BHaH_defines.h must be updated to include these new fields.
  // bhahaha_diags->quasi_local_mass_M = M_quasi_local;

  return 0; // BHAHAHA_SUCCESS
"""
    cfc.register_CFunction(
        subdirectory="",
        includes=includes,
        prefunc=prefunc,
        desc=desc,
        cfunc_type=cfunc_type,
        name=name,
        params=params,
        include_CodeParameters_h=False,
        body=body,
    )
    return pcg.NRPyEnv()
