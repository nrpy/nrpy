"""
C function registration for the top-level diagnostics() driver.

This module constructs and registers the C diagnostics() driver and the commondata
parameter diagnostics_output_every. The generated C code determines whether the
current step is an output step from time, dt, and diagnostics_output_every; allocates
and initializes diagnostic_gfs; conditionally calls enabled diagnostics families
(nearest, interpolation, and volume integration); releases temporary storage; and
advances the progress indicator. Hooks to free and later restore MoL scratch arrays
are present but currently disabled in the emitted code.

Function
---------
register_CFunction_diagnostics
    Construct and register the "diagnostics()" C driver; also registers "diagnostics_output_every".

Author: Zachariah B. Etienne
        zachetie **at** gmail **dot* com
"""

from inspect import currentframe as cfr
from types import FrameType as FT
from typing import Set, Union, cast

import nrpy.c_function as cfc
import nrpy.helpers.parallel_codegen as pcg
import nrpy.params as par
from nrpy.helpers.generic import copy_files
from nrpy.infrastructures import BHaH


def _register_CFunction_diagnostics(  # pylint: disable=unused-argument
    default_diagnostics_out_every: float,
    enable_nearest_diagnostics: bool,
    enable_interp_diagnostics: bool,
    enable_volume_integration_diagnostics: bool,
    enable_free_auxevol: bool = True,
) -> Union[None, pcg.NRPyEnv_type]:
    """
    Construct and register a C function that drives all scheduled diagnostics.

    This function generates and registers the C driver "diagnostics", which is called
    once per timestep to run the enabled diagnostics families at a user-controlled
    cadence. It also registers the commondata CodeParameter diagnostics_output_every.
    At runtime, the generated C code determines whether the current time is within
    half a timestep of the nearest multiple of diagnostics_output_every. On output
    steps it allocates and populates diagnostic_gfs via diagnostic_gfs_set(...),
    invokes the enabled diagnostics routines (diagnostics_nearest(...),
    diagnostics_interp(...), and/or diagnostics_volume_integration(...)), then frees
    temporary storage. CUDA builds additionally synchronize host copies of selected
    device buffers prior to I/O. Hooks to free and later restore MoL scratch arrays
    exist but are currently disabled in the emitted C code.

    :param default_diagnostics_out_every: Default value for the commondata parameter
        "diagnostics_output_every", which controls the diagnostics output cadence.
    :param enable_nearest_diagnostics: If True, include a call to diagnostics_nearest(...)
        on output steps.
    :param enable_interp_diagnostics: If True, include a call to diagnostics_interp(...)
        on output steps.
    :param enable_volume_integration_diagnostics: If True, include a call to
        diagnostics_volume_integration(...) on output steps.
    :param enable_free_auxevol: Reserved for future use. Intended to control whether MoL
        scratch arrays are freed before diagnostics and restored afterward; currently
        ignored by the generated code.
    :return: None if in registration phase (after recording the requested registration),
        else the updated NRPy environment.

    Doctests:
    TBD
    """
    if pcg.pcg_registration_phase():
        pcg.register_func_call(f"{__name__}.{cast(FT, cfr()).f_code.co_name}", locals())
        return None

    # --- C Function Registration ---
    includes = [
        "BHaH_defines.h",
        "BHaH_function_prototypes.h",
        "diagnostics/diagnostic_gfs.h",
    ]
    desc = """
 * @file diagnostics.c
 * @brief Top-level driver that schedules and runs all enabled diagnostics.
 *
 * The function "diagnostics" is generated by NRPy and invoked once per timestep.
 * It checks whether the current time falls on a diagnostics output step. On output
 * steps it allocates per-grid temporary arrays (diagnostic_gfs), initializes them
 * via diagnostic_gfs_set(...), and runs the enabled diagnostics families
 * (for example diagnostics_nearest(...), diagnostics_interp(...), and
 * diagnostics_volume_integration(...)). Temporary storage is freed before
 * returning. Independently of output steps, a progress indicator is advanced
 * every call, and a trailing newline is printed when the run is about to finish.
 *
 * Scheduling rule:
 *   fabs(round(time / diagnostics_output_every) * diagnostics_output_every - time) < 0.5 * dt
 *
 * CUDA note: When compiled with CUDA, device-to-host synchronization of selected
 * buffers occurs prior to performing diagnostics that require host-side I/O, and
 * an additional griddata_device parameter is present in the signature.
 *
 * @pre
 * - commondata and griddata are non-null and initialized.
 * - commondata->NUMGRIDS >= 1, grid dimensions are valid, and backing arrays exist.
 * - Generated diagnostics interfaces and indices are consistent with the build.
 *
 * @post
 * - On output steps, all enabled diagnostics execute and may write output.
 * - On non-output steps, no diagnostic I/O occurs and the solution state is unchanged.
 * - The progress indicator advances every call; a newline is printed if time + dt > t_final.
 *
 * @param[in,out] commondata  Global simulation metadata and run-time parameters
 *                            (e.g., time, dt, diagnostics_output_every, t_final, NUMGRIDS).
 * @param[in,out] griddata_device  Device-side per-grid data used for device-to-host
 *                                 synchronization when compiled with CUDA; omitted in non-CUDA builds.
 * @param[in,out] griddata    Host-side per-grid data (parameters, fields, and workspace).
 *
 * @warning
 * - Diagnostics that encounter allocation or I/O failures may abort the program.
 * - The set of diagnostics compiled in is fixed at code generation time; manual changes
 *   must remain consistent with generated headers and prototypes.
 *
 * If a user-editable block is provided by the build, it may be used to add custom
 * diagnostics or I/O behaviors; details are intentionally omitted here.
 *
 * @return void
"""
    parallelization = par.parval_from_str("parallelization")
    _ = par.CodeParameter(
        "REAL",
        __name__,
        "diagnostics_output_every",
        default_diagnostics_out_every,
        commondata=True,
    )
    cfunc_type = "void"
    name = "diagnostics"
    params = (
        "commondata_struct *restrict commondata, griddata_struct *restrict griddata"
    )
    if parallelization == "cuda":
        params = "commondata_struct *restrict commondata, griddata_struct *restrict griddata_device, griddata_struct *restrict griddata"
    newline = "\n"  # Backslashes aren't allowed in Python 3.7 f-strings; this is our workaround.
    rnewline = "\\n"  # Backslashes aren't allowed in Python 3.7 f-strings; this is our workaround.
    body = f"""
  const REAL currtime = commondata->time, currdt = commondata->dt, outevery = commondata->diagnostics_output_every;
  // Explanation of the if() below:
  // Step 1: round(currtime / outevery) rounds to the nearest integer multiple of currtime/outevery.
  // Step 2: Multiplying by outevery yields the exact time we should output again, t_out.
  // Step 3: If fabs(t_out - currtime) < 0.5 * currdt, then currtime is as close to t_out as possible!
  if (fabs(round(currtime / outevery) * outevery - currtime) < 0.5 * currdt) {{
    // Diagnostics require additional memory, so first free all scratch storage needed for MoL timestepping.
    // FIXME: will address this later. Make code work first, then optimize later.
    // for (int grid = 0; grid < commondata->NUMGRIDS; grid++)
    //   MoL_free_intermediate_stage_gfs(&griddata[grid].gridfuncs);

    // Allocate temporary storage for diagnostic_gfs.
    REAL *diagnostic_gfs[MAXNUMGRIDS];
    for (int grid = 0; grid < commondata->NUMGRIDS; grid++) {{
      SET_NXX_PLUS_2NGHOSTS_VARS(grid);
      const int Nxx_plus_2NGHOSTS_tot = Nxx_plus_2NGHOSTS0 * Nxx_plus_2NGHOSTS1 * Nxx_plus_2NGHOSTS2;
      BHAH_MALLOC(diagnostic_gfs[grid], TOTAL_NUM_DIAG_GFS * Nxx_plus_2NGHOSTS_tot * sizeof(REAL));

#ifdef __CUDACC__
      // This does not leverage async memory transfers using multiple streams at the moment
      // given the current intent is one cuda stream per grid. This could be leveraged
      // in the future by increasing NUM_STREAMS such that a diagnostic stream is included per grid
      const params_struct *restrict params = &griddata_device[grid].params;
      size_t streamid = params->grid_idx % NUM_STREAMS;
      cpyHosttoDevice_params__constant(&griddata_device[grid].params, streamid);
      // Copy solution to host
      for(int gf=0;gf<NUM_EVOL_GFS;gf++)
        cpyDevicetoHost__gf(commondata, params, griddata[grid].gridfuncs.y_n_gfs, griddata_device[grid].gridfuncs.y_n_gfs, gf,gf, streamid);
      // Sync data before attempting to write to file
      cudaStreamSynchronize(streams[streamid]);
#endif // __CUDACC__
    }} // END LOOP over grids

    // Set diagnostics_gfs -- see nrpy/infrastructures/BHaH/[project]/diagnostics/ for definition.
    diagnostic_gfs_set(commondata, griddata, diagnostic_gfs);

    {"// Nearest-point diagnostics, at center, along y,z axes (1D) and xy and yz planes (2D)." if enable_nearest_diagnostics else ""}
    {"diagnostics_nearest(commondata, griddata, (const double **)diagnostic_gfs);" + newline if enable_nearest_diagnostics else ""}
    {"// Interpolation diagnostics, at center, along x,y,z axes (1D) and xy and yz planes (2D)." if enable_interp_diagnostics else ""}
    {"diagnostics_interp(commondata, griddata, (const double **)diagnostic_gfs);" + newline if enable_interp_diagnostics else ""}
    {"// Volume-integration diagnostics." if enable_volume_integration_diagnostics else ""}
    {"diagnostics_volume_integration(commondata, griddata, (const double **)diagnostic_gfs);" + newline if enable_volume_integration_diagnostics else ""}
    // Free temporary storage allocated to diagnostic_gfs.
    for(int grid=0; grid<commondata->NUMGRIDS; grid++)
      free(diagnostic_gfs[grid]);

    // Re-allocate all scratch storage needed for resumption of MoL timestepping.
    // FIXME: will address this later. Make code work first, then optimize later.
    // for (int grid = 0; grid < commondata->NUMGRIDS; grid++)
    //   MoL_malloc_intermediate_stage_gfs(commondata, &griddata[grid].params, &griddata[grid].gridfuncs);
  }} // END if output step

  progress_indicator(commondata, griddata);
  if (commondata->time + commondata->dt > commondata->t_final) printf("{rnewline}");
"""
    cfc.register_CFunction(
        subdirectory="diagnostics",
        includes=includes,
        desc=desc,
        cfunc_type=cfunc_type,
        name=name,
        params=params,
        include_CodeParameters_h=False,
        body=body,
    )
    return pcg.NRPyEnv()


def register_all_diagnostics(
    project_dir: str,
    set_of_CoordSystems: Set[str],
    default_diagnostics_out_every: float,
    enable_nearest_diagnostics: bool,
    enable_interp_diagnostics: bool,
    enable_volume_integration_diagnostics: bool,
    enable_free_auxevol: bool = True,
) -> None:
    """
    Register and stage all diagnostics-related C code and helper headers.

    This function copies required helper headers into the project's diagnostics
    subdirectory based on which diagnostics families are enabled, registers the
    top-level diagnostics() C driver with the requested default output cadence,
    and registers any family-specific C helpers for each coordinate system.

    :param project_dir: Target project directory for emitted diagnostics assets.
    :param set_of_CoordSystems: Set of coordinate-system names to generate helpers for.
    :param default_diagnostics_out_every: Default value for the commondata parameter
        "diagnostics_output_every" controlling output cadence.
    :param enable_nearest_diagnostics: If True, include sampling-based "nearest" diagnostics.
    :param enable_interp_diagnostics: If True, include interpolation-based diagnostics.
    :param enable_volume_integration_diagnostics: If True, include volume-integration diagnostics.
    :param enable_free_auxevol: Reserved for future use; currently ignored by the generated code.

    Doctests:
    TBD
    """
    filenames_list_to_copy = []
    if enable_nearest_diagnostics:
        filenames_list_to_copy += ["diagnostics_nearest_common.h"]
    if enable_volume_integration_diagnostics:
        filenames_list_to_copy += ["diagnostics_volume_integration_helpers.h"]
    if filenames_list_to_copy:
        copy_files(
            package="nrpy.infrastructures.BHaH.diagnostics",
            filenames_list=filenames_list_to_copy,
            project_dir=project_dir,
            subdirectory="diagnostics",
        )

    _register_CFunction_diagnostics(
        default_diagnostics_out_every=default_diagnostics_out_every,
        enable_nearest_diagnostics=enable_nearest_diagnostics,
        enable_interp_diagnostics=enable_interp_diagnostics,
        enable_volume_integration_diagnostics=enable_volume_integration_diagnostics,
        enable_free_auxevol=enable_free_auxevol,
    )
    if enable_nearest_diagnostics:
        for CoordSystem in set_of_CoordSystems:
            BHaH.diagnostics.diagnostics_nearest_grid_center.register_CFunction_diagnostics_nearest_grid_center(
                CoordSystem=CoordSystem
            )
            BHaH.diagnostics.diagnostics_nearest_1d_y_and_z_axes.register_CFunction_diagnostics_nearest_1d_y_and_z_axes(
                CoordSystem=CoordSystem
            )
            BHaH.diagnostics.diagnostics_nearest_2d_xy_and_yz_planes.register_CFunction_diagnostics_nearest_2d_xy_and_yz_planes(
                CoordSystem=CoordSystem
            )
    if enable_volume_integration_diagnostics:
        for CoordSystem in set_of_CoordSystems:
            BHaH.diagnostics.sqrt_detgammahat_d3xx_volume_element.register_CFunction_sqrt_detgammahat_d3xx_volume_element(
                CoordSystem=CoordSystem
            )


if __name__ == "__main__":
    import doctest
    import sys

    results = doctest.testmod()

    if results.failed > 0:
        print(f"Doctest failed: {results.failed} of {results.attempted} test(s)")
        sys.exit(1)
    else:
        print(f"Doctest passed: All {results.attempted} test(s) passed")
