"""
Generate the C header file `diagnostic_gfs.h`.

This module provides a single function, `diagnostics_gfs_h_create`, that
generates a C header file defining all available diagnostic quantities for the
simulation. The header serves as the single source of truth for diagnostic
gridfunctions.

The generated header contains two key components based on a user-provided
Python dictionary:
  - An enum where each token corresponds to a diagnostic gridfunction (e.g.,
    `DIAG_RHO`), terminated by a `TOTAL_NUM_DIAG_GFS` counter.
  - A companion `const char *` array that maps each enum token to a short,
    human-readable C string name (e.g., "rho") using C99 designated
    initializers.

This module is intended to be called after NRPy's parallel code generation phase.

Functions
---------
diagnostics_gfs_h_create
    Constructs and writes the `diagnostic_gfs.h` header file.

Author: Zachariah B. Etienne
        zachetie **at** gmail **dot* com
"""

from pathlib import Path
from typing import Dict

import nrpy.helpers.parallel_codegen as pcg
from nrpy.helpers.generic import clang_format


def diagnostics_gfs_h_create(
    project_dir: str,
    diagnostic_gfs_names_dict: Dict[str, str],
) -> None:
    """
    Generate and write the `diagnostic_gfs.h` C header file.

    This function takes a dictionary of diagnostic gridfunction names and uses it
    to construct a C header file. The file defines an enum of all diagnostic
    quantities and a parallel array of corresponding string names.

    The process involves:
      1. Creating an enum from the keys of `diagnostic_gfs_names_dict`, with
         a final `TOTAL_NUM_DIAG_GFS` member to count the total number.
      2. Creating a `const char *` array `diagnostic_gf_names` that maps each
         enum token to its string name from the dictionary's values. This mapping
         is made robust by using C99 designated initializers.
      3. Wrapping the definitions in standard header guards and an `extern "C"`
         block for C++ compatibility.
      4. Formatting the generated C code using clang-format.
      5. Writing the final content to `project_dir/diagnostics/diagnostic_gfs.h`.

    :param project_dir: The root output directory for the project. The header
                        is written into a "diagnostics" subdirectory within it.
    :param diagnostic_gfs_names_dict: A dictionary where keys are the C enum
                                      tokens (e.g., "DIAG_RHO") and values are
                                      the short, one-word C string names
                                      (e.g., "rho").
    :raises EnvironmentError: If called during the parallel codegen registration
                              phase, as it must run after.
    """
    if pcg.pcg_registration_phase():
        raise EnvironmentError(
            "diagnostics_gfs_h_create() must be called AFTER parallel codegen."
        )

    newline = "\n"  # Needed for Python 3.7 compatibility in the f-strings below
    body = rf"""
/**
 * @file diagnostic_gfs.h
 * @brief Defines the enum and name table for all diagnostic gridfunctions.
 * @details
 * This header provides the single source of truth for all diagnostic
 * quantities available for interpolation and output. It is automatically
 * generated by NRPy from a Python dictionary.
 *
 * It defines two key components:
 *
 *   1. An anonymous enum that lists all diagnostic gridfunction tokens (e.g.,
 *      DIAG_RHO, DIAG_UX). This list is terminated by the special member
 *      `TOTAL_NUM_DIAG_GFS`, which provides a convenient compile-time count
 *      of the total number of diagnostics.
 *
 *   2. A static const array of C strings, `diagnostic_gf_names`, which maps
 *      each enum token to a short, human-readable name (e.g., "rho", "ux").
 *      This mapping uses C99 designated initializers for robustness against
 *      changes in the enum's order.
 *
 * The contents are wrapped in an `extern "C"` block to ensure
 * compatibility with C++ compilers.
 *
 * @note This file is auto-generated and should not be edited by hand.
 *       Changes should be made in the corresponding NRPy Python code.
 *
 * Author: Zachariah B. Etienne
 *         zachetie **at** gmail **dot* com
 */

#ifndef DIAGNOSTIC_GFS_H
#define DIAGNOSTIC_GFS_H

#ifdef __cplusplus
extern "C" {{
#endif

// This enum defines all available diagnostic gridfunctions.
// It is the single source of truth for diagnostic quantities.
enum {{
{
    newline.join(
        [f"      {item}," for item in list(diagnostic_gfs_names_dict.keys())] +
        ["      TOTAL_NUM_DIAG_GFS // must be last: total produced diagnostics (== count)"]
    )
    }
}};

#ifdef __cplusplus
  #define DIAG_INIT(idx, val) val
#else
  #define DIAG_INIT(idx, val) [idx] = val
#endif

// Human-friendly, one-word names for each diagnostic gridfunction.
// Using C99 designated initializers makes this robust against reordering the enum.
MAYBE_UNUSED static const char *diagnostic_gf_names[TOTAL_NUM_DIAG_GFS] = {{
{
    newline.join(
        f'      DIAG_INIT({key}, "{value}"), //'
        for key, value in diagnostic_gfs_names_dict.items()
    )
    }
}};

#ifdef __cplusplus
}} // extern "C"
#endif

#endif // DIAGNOSTIC_GFS_H
"""

    p = Path(project_dir) / "diagnostics" / "diagnostic_gfs.h"
    p.parent.mkdir(parents=True, exist_ok=True)  # create dir/subdirs if missing
    p.write_text(clang_format(body), encoding="utf-8")
