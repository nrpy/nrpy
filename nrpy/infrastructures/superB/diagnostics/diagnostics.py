"""
C function registration for the top-level diagnostics() driver.

This module constructs and registers the C diagnostics() driver and the commondata
parameter diagnostics_output_every. The generated C code determines whether the
current step is an output step from time, dt, and diagnostics_output_every; allocates
and initializes diagnostic_gfs; conditionally calls enabled diagnostics families
(nearest, interpolation, and volume integration); releases temporary storage; and
advances the progress indicator. Hooks to free and later restore MoL scratch arrays
are present but currently disabled in the emitted code.

Function
---------
register_CFunction_diagnostics
    Construct and register the "diagnostics()" C driver; also registers "diagnostics_output_every".

Author: Zachariah B. Etienne
        zachetie **at** gmail **dot* com
        Nishita Jadoo
        njadoo **at** uidaho **dot* edu
"""

from inspect import currentframe as cfr
from types import FrameType as FT
from typing import Set, Union, cast

import nrpy.c_function as cfc
import nrpy.helpers.parallel_codegen as pcg
import nrpy.params as par
from nrpy.helpers.generic import copy_files
from nrpy.infrastructures import BHaH, superB


def _register_CFunction_diagnostics(  # pylint: disable=unused-argument
    default_diagnostics_out_every: float,
    enable_nearest_diagnostics: bool,
    enable_interp_diagnostics: bool,
    enable_volume_integration_diagnostics: bool,
    enable_free_auxevol: bool = True,
) -> Union[None, pcg.NRPyEnv_type]:
    """
    Construct and register the top-level C diagnostics dispatcher.

    This function generates and registers the C driver "diagnostics", which is
    invoked by the Charm++ timestepping/control-flow layer on scheduled diagnostics
    phases. The driver itself does not decide when diagnostics should run (it does
    not inspect time, dt, or diagnostics_output_every), and it does not allocate or
    populate diagnostic gridfunction buffers; instead it operates on already-allocated
    gridfuncs_diags buffers provided by the caller.

    This function still registers the commondata CodeParameter diagnostics_output_every,
    but that parameter is consulted by the Charm++ layer (caller) to determine the
    output cadence.

    :param default_diagnostics_out_every: Default value for the commondata parameter
        "diagnostics_output_every", which controls the diagnostics output cadence (as
        interpreted by the caller).
    :param enable_nearest_diagnostics: If True, include a call to diagnostics_nearest(...)
        when the corresponding diagnostics phase is invoked.
    :param enable_interp_diagnostics: If True, include a call to diagnostics_interp(...)
        when the corresponding diagnostics phase is invoked.
    :param enable_free_auxevol: Reserved for future use. Intended to control whether MoL
        scratch arrays are freed before diagnostics and restored afterward; currently
        ignored by the generated code.
    :return: None if in registration phase (after recording the requested registration),
        else the updated NRPy environment.

    Doctests:
    TBD
    """
    if pcg.pcg_registration_phase():
        pcg.register_func_call(f"{__name__}.{cast(FT, cfr()).f_code.co_name}", locals())
        return None

    # --- C Function Registration ---
    includes = [
        "BHaH_defines.h",
        "BHaH_function_prototypes.h",
        "diagnostics/diagnostic_gfs.h",
    ]
    desc = """
 * @file diagnostics.c
 * @brief Top-level driver that schedules and runs all enabled diagnostics.
 *
 * The function "diagnostics" is generated by NRPy and invoked once per timestep.
 * Scheduling:
 *   This driver does not decide whether diagnostics run on a given step.
 *   The caller (Charm++ control flow) must invoke the appropriate DIAGNOSTICS_* phase only
 *   on scheduled output steps.*
 *
 * @param[in,out] commondata  Global simulation metadata and run-time parameters.
 * @param[in,out] griddata    Host-side per-grid data (parameters, fields, and workspace).
 * @param[in,out] griddata_chare  Per-chare grid data used by Charm++ diagnostics routines.
 * @param[in]     gridfuncs_diags  Per-grid diagnostic gridfunction pointers (may be NULL for setup stages).
 * @param[in]     chare_index  3D chare index identifying this subdomain.
 * @param[in]     grid         Grid index within [0, commondata->NUMGRIDS).
 * @param[in]     token        Ck::IO session token used by I/O routines.
 * @param[in]     which_diagnostics_part  Enum selecting the diagnostics stage/action.
 *
 * @warning
 * - Diagnostics that encounter allocation or I/O failures may abort the program.
 * - The set of diagnostics compiled in is fixed at code generation time; manual changes
 *   must remain consistent with generated headers and prototypes.
 *
 * If a user-editable block is provided by the build, it may be used to add custom
 * diagnostics or I/O behaviors; details are intentionally omitted here.
 *
 * @return void
"""
    _ = par.CodeParameter(
        "REAL",
        __name__,
        "diagnostics_output_every",
        default_diagnostics_out_every,
        commondata=True,
    )
    cfunc_type = "void"
    name = "diagnostics"
    params = (
        "commondata_struct *restrict commondata, griddata_struct *restrict griddata, griddata_struct *restrict griddata_chare, "
        "const REAL *restrict gridfuncs_diags[MAXNUMGRIDS], "
        "const int chare_index[3], const int grid, Ck::IO::Session token, const int which_diagnostics_part"
    )

    body = r"""
  switch (which_diagnostics_part) {

    case DIAGNOSTICS_SETUP_1D:
    case DIAGNOSTICS_SETUP_2D: {"""

    if enable_nearest_diagnostics:
        body += r"""
      // Nearest-point diagnostics, at center, along y,z axes (1D)
      diagnostics_nearest(commondata, griddata, griddata_chare, NULL, chare_index, token, which_diagnostics_part);"""

    body += r"""
      break;
    }

    case DIAGNOSTICS_WRITE_CENTER:
    case DIAGNOSTICS_WRITE_Y:
    case DIAGNOSTICS_WRITE_Z:
    case DIAGNOSTICS_WRITE_XY:
    case DIAGNOSTICS_WRITE_YZ: {"""

    if enable_nearest_diagnostics:
        body += r"""
      // Nearest-point diagnostics at xy and yz planes (2D).
      diagnostics_nearest(commondata, griddata, griddata_chare, gridfuncs_diags, chare_index, token, which_diagnostics_part);"""

    body += r"""
      break;
    }
  }
"""
    cfc.register_CFunction(
        subdirectory="diagnostics",
        includes=includes,
        desc=desc,
        cfunc_type=cfunc_type,
        name=name,
        params=params,
        include_CodeParameters_h=False,
        body=body,
    )
    return pcg.NRPyEnv()


def register_all_diagnostics(
    project_dir: str,
    set_of_CoordSystems: Set[str],
    default_diagnostics_out_every: float,
    enable_nearest_diagnostics: bool,
    enable_interp_diagnostics: bool,
    enable_volume_integration_diagnostics: bool,
    enable_free_auxevol: bool = True,
) -> None:
    """
    Register and stage all diagnostics-related C code and helper headers.

    This function copies required helper headers into the project's diagnostics
    subdirectory based on which diagnostics families are enabled, registers the
    top-level diagnostics() C driver with the requested default output cadence,
    and registers any family-specific C helpers for each coordinate system.

    :param project_dir: Target project directory for emitted diagnostics assets.
    :param set_of_CoordSystems: Set of coordinate-system names to generate helpers for.
    :param default_diagnostics_out_every: Default value for the commondata parameter
        "diagnostics_output_every" controlling output cadence.
    :param enable_nearest_diagnostics: If True, include sampling-based "nearest" diagnostics.
    :param enable_interp_diagnostics: If True, include interpolation-based diagnostics.
    :param enable_volume_integration_diagnostics: If True, include volume-integration diagnostics.
    :param enable_free_auxevol: Reserved for future use; currently ignored by the generated code.

    Doctests:
    TBD
    """
    filenames_list_to_copy = []
    if enable_nearest_diagnostics:
        filenames_list_to_copy += ["diagnostics_nearest_common.h"]
    if enable_volume_integration_diagnostics:
        filenames_list_to_copy += ["diagnostics_volume_integration_helpers.h"]
    if filenames_list_to_copy:
        copy_files(
            package="nrpy.infrastructures.BHaH.diagnostics",
            filenames_list=filenames_list_to_copy,
            project_dir=project_dir,
            subdirectory="diagnostics",
        )

    _register_CFunction_diagnostics(
        default_diagnostics_out_every=default_diagnostics_out_every,
        enable_nearest_diagnostics=enable_nearest_diagnostics,
        enable_interp_diagnostics=enable_interp_diagnostics,
        enable_volume_integration_diagnostics=enable_volume_integration_diagnostics,
        enable_free_auxevol=enable_free_auxevol,
    )
    if enable_nearest_diagnostics:
        for CoordSystem in set_of_CoordSystems:
            superB.diagnostics.diagnostics_nearest_grid_center.register_CFunction_diagnostics_nearest_grid_center(
                CoordSystem=CoordSystem
            )
            superB.diagnostics.diagnostics_nearest_1d_y_and_z_axes.register_CFunction_diagnostics_nearest_1d_y_and_z_axes(
                CoordSystem=CoordSystem
            )
            superB.diagnostics.diagnostics_nearest_2d_xy_and_yz_planes.register_CFunction_diagnostics_nearest_2d_xy_and_yz_planes(
                CoordSystem=CoordSystem
            )
    if enable_volume_integration_diagnostics:
        for CoordSystem in set_of_CoordSystems:
            BHaH.diagnostics.sqrt_detgammahat_d3xx_volume_element.register_CFunction_sqrt_detgammahat_d3xx_volume_element(
                CoordSystem=CoordSystem
            )

    # Register diagnostic_struct's contribution to griddata_struct:
    BHaH.griddata_commondata.register_griddata_commondata(
        __name__,
        "diagnostic_struct diagnosticstruct",
        "store indices of 1d and 2d diagnostic points, the offset in the output file, etc",
    )


if __name__ == "__main__":
    import doctest
    import sys

    results = doctest.testmod()

    if results.failed > 0:
        print(f"Doctest failed: {results.failed} of {results.attempted} test(s)")
        sys.exit(1)
    else:
        print(f"Doctest passed: All {results.attempted} test(s) passed")
