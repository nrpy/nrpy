"""
C function registration for the top-level diagnostics() driver.

This module constructs and registers the C diagnostics() driver and the commondata
parameter diagnostics_output_every. The generated C code determines whether the
current step is an output step from time, dt, and diagnostics_output_every; allocates
and initializes diagnostic_gfs; conditionally calls enabled diagnostics families
(nearest, interpolation, and volume integration); releases temporary storage; and
advances the progress indicator. Hooks to free and later restore MoL scratch arrays
are present but currently disabled in the emitted code.

Function
---------
register_CFunction_diagnostics
    Construct and register the "diagnostics()" C driver; also registers "diagnostics_output_every".

Author: Zachariah B. Etienne
        zachetie **at** gmail **dot* com
"""

from inspect import currentframe as cfr
from types import FrameType as FT
from typing import Set, Union, cast

import nrpy.c_function as cfc
import nrpy.helpers.parallel_codegen as pcg
import nrpy.params as par
from nrpy.helpers.generic import copy_files
from nrpy.infrastructures import BHaH, superB


def _register_CFunction_diagnostics(  # pylint: disable=unused-argument
    default_diagnostics_out_every: float,
    enable_nearest_diagnostics: bool,
    enable_interp_diagnostics: bool,
    enable_volume_integration_diagnostics: bool,
    enable_free_auxevol: bool = True,
) -> Union[None, pcg.NRPyEnv_type]:
    """
    Construct and register a C function that drives all scheduled diagnostics.

    This function generates and registers the C driver "diagnostics", which is called
    once per timestep to run the enabled diagnostics families at a user-controlled
    cadence. It also registers the commondata CodeParameter diagnostics_output_every.
    At runtime, the generated C code determines whether the current time is within
    half a timestep of the nearest multiple of diagnostics_output_every. On output
    steps it allocates and populates diagnostic_gfs via diagnostic_gfs_set(...),
    invokes the enabled diagnostics routines (diagnostics_nearest(...),
    diagnostics_interp(...), and/or diagnostics_volume_integration(...)), then frees
    temporary storage. CUDA builds additionally synchronize host copies of selected
    device buffers prior to I/O. Hooks to free and later restore MoL scratch arrays
    exist but are currently disabled in the emitted C code.

    :param default_diagnostics_out_every: Default value for the commondata parameter
        "diagnostics_output_every", which controls the diagnostics output cadence.
    :param enable_nearest_diagnostics: If True, include a call to diagnostics_nearest(...)
        on output steps.
    :param enable_interp_diagnostics: If True, include a call to diagnostics_interp(...)
        on output steps.
    :param enable_volume_integration_diagnostics: If True, include a call to
        diagnostics_volume_integration(...) on output steps.
    :param enable_free_auxevol: Reserved for future use. Intended to control whether MoL
        scratch arrays are freed before diagnostics and restored afterward; currently
        ignored by the generated code.
    :return: None if in registration phase (after recording the requested registration),
        else the updated NRPy environment.

    Doctests:
    TBD
    """
    if pcg.pcg_registration_phase():
        pcg.register_func_call(f"{__name__}.{cast(FT, cfr()).f_code.co_name}", locals())
        return None

    # --- C Function Registration ---
    includes = [
        "BHaH_defines.h",
        "BHaH_function_prototypes.h",
        "diagnostics/diagnostic_gfs.h",
    ]
    desc = """
 * @file diagnostics.c
 * @brief Top-level driver that schedules and runs all enabled diagnostics.
 *
 * The function "diagnostics" is generated by NRPy and invoked once per timestep.
 * It checks whether the current time falls on a diagnostics output step. On output
 * steps it allocates per-grid temporary arrays (diagnostic_gfs), initializes them
 * via diagnostic_gfs_set(...), and runs the enabled diagnostics families
 * (for example diagnostics_nearest(...), diagnostics_interp(...), and
 * diagnostics_volume_integration(...)). Temporary storage is freed before
 * returning. Independently of output steps, a progress indicator is advanced
 * every call, and a trailing newline is printed when the run is about to finish.
 *
 * Scheduling rule:
 *   fabs(round(time / diagnostics_output_every) * diagnostics_output_every - time) < 0.5 * dt
 *
 * CUDA note: When compiled with CUDA, device-to-host synchronization of selected
 * buffers occurs prior to performing diagnostics that require host-side I/O, and
 * an additional griddata_device parameter is present in the signature.
 *
 * @pre
 * - commondata and griddata are non-null and initialized.
 * - commondata->NUMGRIDS >= 1, grid dimensions are valid, and backing arrays exist.
 * - Generated diagnostics interfaces and indices are consistent with the build.
 *
 * @post
 * - On output steps, all enabled diagnostics execute and may write output.
 * - On non-output steps, no diagnostic I/O occurs and the solution state is unchanged.
 * - The progress indicator advances every call; a newline is printed if time + dt > t_final.
 *
 * @param[in,out] commondata  Global simulation metadata and run-time parameters
 *                            (e.g., time, dt, diagnostics_output_every, t_final, NUMGRIDS).
 * @param[in,out] griddata_device  Device-side per-grid data used for device-to-host
 *                                 synchronization when compiled with CUDA; omitted in non-CUDA builds.
 * @param[in,out] griddata    Host-side per-grid data (parameters, fields, and workspace).
 *
 * @warning
 * - Diagnostics that encounter allocation or I/O failures may abort the program.
 * - The set of diagnostics compiled in is fixed at code generation time; manual changes
 *   must remain consistent with generated headers and prototypes.
 *
 * If a user-editable block is provided by the build, it may be used to add custom
 * diagnostics or I/O behaviors; details are intentionally omitted here.
 *
 * @return void
"""
    parallelization = par.parval_from_str("parallelization")
    _ = par.CodeParameter(
        "REAL",
        __name__,
        "diagnostics_output_every",
        default_diagnostics_out_every,
        commondata=True,
    )
    cfunc_type = "void"
    name = "diagnostics"
    params = (
    "commondata_struct *restrict commondata, griddata_struct *restrict griddata, griddata_struct *restrict griddata_chare, "
    "const REAL *restrict gridfuncs_diags[MAXNUMGRIDS], "
    "const int chare_index[3], const int grid, Ck::IO::Session token, const int which_diagnostics_part"
    )
    
    newline = "\n"  # Backslashes aren't allowed in Python 3.7 f-strings; this is our workaround.
    rnewline = "\\n"  # Backslashes aren't allowed in Python 3.7 f-strings; this is our workaround.
    body = r"""
  switch (which_diagnostics_part) {

    case DIAGNOSTICS_SETUP_1D:
    case DIAGNOSTICS_SETUP_2D: {

      // Nearest-point diagnostics, at center, along y,z axes (1D)
      diagnostics_nearest(commondata, griddata, griddata_chare, NULL, chare_index, token, which_diagnostics_part);

      printf("Finished diag 1d and 2d setupts!!!!!!!!!!!!!!!!!!!\n");

      break;
    }

    case DIAGNOSTICS_WRITE_CENTER:
    case DIAGNOSTICS_WRITE_Y:
    case DIAGNOSTICS_WRITE_Z:
    case DIAGNOSTICS_WRITE_XY:
    case DIAGNOSTICS_WRITE_YZ: {

      // Nearest-point diagnostics at xy and yz planes (2D).
      diagnostics_nearest(commondata, griddata, griddata_chare, gridfuncs_diags, chare_index, token, which_diagnostics_part);

      break;
    }

    case DIAGNOSTICS_VOLUME_EXECUTE_RECIPE_FOR_CHARE_GRID:
    case DIAGNOSTICS_VOLUME_WRITE: {

      // Volume-integration diagnostics.
      //diagnostics_volume_integration(commondata, griddata, griddata_chare, gridfuncs_diags, chare_index, which_diagnostics_part);

      break;
    }
  }
"""
    cfc.register_CFunction(
        subdirectory="diagnostics",
        includes=includes,
        desc=desc,
        cfunc_type=cfunc_type,
        name=name,
        params=params,
        include_CodeParameters_h=False,
        body=body,
    )
    return pcg.NRPyEnv()


def register_all_diagnostics(
    project_dir: str,
    set_of_CoordSystems: Set[str],
    default_diagnostics_out_every: float,
    enable_nearest_diagnostics: bool,
    enable_interp_diagnostics: bool,
    enable_volume_integration_diagnostics: bool,
    enable_free_auxevol: bool = True,
) -> None:
    """
    Register and stage all diagnostics-related C code and helper headers.

    This function copies required helper headers into the project's diagnostics
    subdirectory based on which diagnostics families are enabled, registers the
    top-level diagnostics() C driver with the requested default output cadence,
    and registers any family-specific C helpers for each coordinate system.

    :param project_dir: Target project directory for emitted diagnostics assets.
    :param set_of_CoordSystems: Set of coordinate-system names to generate helpers for.
    :param default_diagnostics_out_every: Default value for the commondata parameter
        "diagnostics_output_every" controlling output cadence.
    :param enable_nearest_diagnostics: If True, include sampling-based "nearest" diagnostics.
    :param enable_interp_diagnostics: If True, include interpolation-based diagnostics.
    :param enable_volume_integration_diagnostics: If True, include volume-integration diagnostics.
    :param enable_free_auxevol: Reserved for future use; currently ignored by the generated code.

    Doctests:
    TBD
    """
    filenames_list_to_copy = []
    if enable_nearest_diagnostics:
        filenames_list_to_copy += ["diagnostics_nearest_common.h"]
    if enable_volume_integration_diagnostics:
        filenames_list_to_copy += ["diagnostics_volume_integration_helpers.h"]
    if filenames_list_to_copy:
        copy_files(
            package="nrpy.infrastructures.BHaH.diagnostics",
            filenames_list=filenames_list_to_copy,
            project_dir=project_dir,
            subdirectory="diagnostics",
        )

    _register_CFunction_diagnostics(
        default_diagnostics_out_every=default_diagnostics_out_every,
        enable_nearest_diagnostics=enable_nearest_diagnostics,
        enable_interp_diagnostics=enable_interp_diagnostics,
        enable_volume_integration_diagnostics=enable_volume_integration_diagnostics,
        enable_free_auxevol=enable_free_auxevol,
    )
    if enable_nearest_diagnostics:
        for CoordSystem in set_of_CoordSystems:            
            superB.diagnostics.diagnostics_nearest_grid_center.register_CFunction_diagnostics_nearest_grid_center(
                CoordSystem=CoordSystem
            )
            superB.diagnostics.diagnostics_nearest_1d_y_and_z_axes.register_CFunction_diagnostics_nearest_1d_y_and_z_axes(
                CoordSystem=CoordSystem
            )
            superB.diagnostics.diagnostics_nearest_2d_xy_and_yz_planes.register_CFunction_diagnostics_nearest_2d_xy_and_yz_planes(
                CoordSystem=CoordSystem
            )
    if enable_volume_integration_diagnostics:
        for CoordSystem in set_of_CoordSystems:
            BHaH.diagnostics.sqrt_detgammahat_d3xx_volume_element.register_CFunction_sqrt_detgammahat_d3xx_volume_element(
                CoordSystem=CoordSystem
            )


if __name__ == "__main__":
    import doctest
    import sys

    results = doctest.testmod()

    if results.failed > 0:
        print(f"Doctest failed: {results.failed} of {results.attempted} test(s)")
        sys.exit(1)
    else:
        print(f"Doctest passed: All {results.attempted} test(s) passed")
