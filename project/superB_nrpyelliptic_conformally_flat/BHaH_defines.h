#ifndef __BHAH_DEFINES_H__
#define __BHAH_DEFINES_H__
// BHaH core header file, automatically generated from output_BHaH_defines_h within BHaH_defines_h.py,
//    DO NOT EDIT THIS FILE BY HAND.

// ----------------------------
// Basic definitions for module
// general:
// ----------------------------
#include <ctype.h>   // Character type functions, such as isdigit, isalpha, etc.
#include <errno.h>   // Error number definitions
#include <math.h>    // Transcendental functions, etc.
#include <stdbool.h> // bool-typed variables
#include <stdint.h>  // int8_t-typed variables
#include <stdio.h>   // Basic input/output functions, such as *printf, fopen, fwrite, etc.
#include <stdlib.h>  // malloc/free, etc.
#include <string.h>  // String handling functions, such as strlen, strcmp, etc.
#include <time.h>    // Time-related functions and types, such as time(), clock(),
// output_BHaH_defines_h(...,enable_intrinsics=True) was called so we intrinsics headers:
#include "intrinsics/simd_intrinsics.h"
#include "superB/superB.h"
#define REAL double
#define DOUBLE double

// These macros for MIN(), MAX(), and SQR() ensure that if the arguments inside
//   are a function/complex expression, the function/expression is evaluated
//   *only once* per argument. See https://lwn.net/Articles/983965/ for details.
// They are improvements over the original implementations:
// #define MIN(A, B) ( ((A) < (B)) ? (A) : (B) )
// #define MAX(A, B) ( ((A) > (B)) ? (A) : (B) )
// #define SQR(A) ((A) * (A))
#define MIN(A, B)                                                                                                                                    \
  ({                                                                                                                                                 \
    __typeof__(A) _a = (A);                                                                                                                          \
    __typeof__(B) _b = (B);                                                                                                                          \
    _a < _b ? _a : _b;                                                                                                                               \
  })
#define MAX(A, B)                                                                                                                                    \
  ({                                                                                                                                                 \
    __typeof__(A) _a = (A);                                                                                                                          \
    __typeof__(B) _b = (B);                                                                                                                          \
    _a > _b ? _a : _b;                                                                                                                               \
  })
#define SQR(A)                                                                                                                                       \
  ({                                                                                                                                                 \
    __typeof__(A) _a = (A);                                                                                                                          \
    _a *_a;                                                                                                                                          \
  })
#ifndef MAYBE_UNUSED
#if __cplusplus >= 201703L
#define MAYBE_UNUSED [[maybe_unused]]
#elif defined(__GNUC__) || defined(__clang__) || defined(__NVCC__)
#define MAYBE_UNUSED __attribute__((unused))
#else
#define MAYBE_UNUSED
#endif // END check for GCC, Clang, or NVCC
#endif // END MAYBE_UNUSED
// START: CodeParameters declared as #define.
#ifndef MAXNUMGRIDS
#define MAXNUMGRIDS 15 // nrpy.grid
#endif
// END: CodeParameters declared as #define.

// ----------------------------
// Basic definitions for module
// nrpy.infrastructures.BHaH.diagnostics.progress_indicator:
// ----------------------------
#ifdef __linux__
// Timer with nanosecond resolution. Only on Linux.
#define TIMEVAR struct timespec
#define CURRTIME_FUNC(currtime) clock_gettime(CLOCK_REALTIME, currtime)
#define TIME_IN_NS(start, end) (REAL)(1000000000L * (end.tv_sec - start.tv_sec) + end.tv_nsec - start.tv_nsec);
#else
// Low-resolution timer, 1-second resolution. Widely available.
#define TIMEVAR time_t
#define CURRTIME_FUNC(currtime) time(currtime)
#define TIME_IN_NS(start, end) (REAL)(difftime(end, start) * 1.0e9 + 1e-6) // Round up to avoid divide-by-zero.
#endif

// ----------------------------
// Basic definitions for module
// commondata_struct:
// ----------------------------
typedef struct __commondata_struct__ {
  REAL CFL_FACTOR;               // (nrpy.infrastructures.superB.MoL)
  REAL MINIMUM_GLOBAL_WAVESPEED; // (nrpy.infrastructures.BHaH.nrpyelliptic.auxevol_gfs_set_to_constant)
  REAL P0_x;                     // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL P0_y;                     // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL P0_z;                     // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL P1_x;                     // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL P1_y;                     // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL P1_z;                     // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL S0_x;                     // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL S0_y;                     // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL S0_z;                     // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL S1_x;                     // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL S1_y;                     // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL S1_z;                     // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL bare_mass_0;              // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL bare_mass_1;              // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  REAL convergence_factor;       // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  REAL diagnostics_output_every; // (nrpy.infrastructures.BHaH.diagnostics.diagnostics)
  REAL dt;                       // (nrpy.infrastructures.superB.MoL)
  REAL eta_damping;              // (nrpy.equations.nrpyelliptic.ConformallyFlat_RHSs)
  REAL log10_current_residual;   // (nrpy.infrastructures.BHaH.nrpyelliptic.stop_conditions_check)
  REAL log10_residual_tolerance; // (nrpy.infrastructures.BHaH.nrpyelliptic.stop_conditions_check)
  REAL t_0;                      // (nrpy.infrastructures.superB.MoL)
  REAL t_final;                  // (nrpy.infrastructures.superB.MoL)
  REAL time;                     // (nrpy.infrastructures.superB.MoL)
  REAL zPunc;                    // (nrpy.equations.nrpyelliptic.ConformallyFlat_SourceTerms)
  TIMEVAR start_wallclock_time;  // (nrpy.infrastructures.BHaH.diagnostics.progress_indicator)
  bool stop_relaxation;          // (nrpy.infrastructures.BHaH.nrpyelliptic.stop_conditions_check)
  char outer_bc_type[50];        // (nrpy.infrastructures.BHaH.CurviBoundaryConditions.BHaH_defines)
  int NUMGRIDS;                  // (nrpy.grid)
  int Nchare0;                   // (nrpy.infrastructures.superB.main_chare)
  int Nchare1;                   // (nrpy.infrastructures.superB.main_chare)
  int Nchare2;                   // (nrpy.infrastructures.superB.main_chare)
  int nn;                        // (nrpy.infrastructures.superB.MoL)
  int nn_0;                      // (nrpy.infrastructures.superB.MoL)
  int nn_max;                    // (nrpy.infrastructures.BHaH.nrpyelliptic.stop_conditions_check)
  int output_progress_every;     // (nrpy.infrastructures.BHaH.diagnostics.progress_indicator)
} commondata_struct;

// ----------------------------
// Basic definitions for module
// params_struct:
// ----------------------------
typedef struct __params_struct__ {
  REAL AMPL;                        // (nrpy.reference_metric)
  REAL Cart_originx;                // (nrpy.grid)
  REAL Cart_originy;                // (nrpy.grid)
  REAL Cart_originz;                // (nrpy.grid)
  REAL PI;                          // (nrpy.reference_metric)
  REAL SINHW;                       // (nrpy.reference_metric)
  REAL dxx0;                        // (nrpy.infrastructures.BHaH.diagnostics.sqrt_detgammahat_d3xx_volume_element)
  REAL dxx1;                        // (nrpy.infrastructures.BHaH.diagnostics.sqrt_detgammahat_d3xx_volume_element)
  REAL dxx2;                        // (nrpy.infrastructures.BHaH.diagnostics.sqrt_detgammahat_d3xx_volume_element)
  REAL grid_hole_radius;            // (nrpy.reference_metric)
  REAL grid_physical_size;          // (nrpy.reference_metric)
  REAL invdxx0;                     // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  REAL invdxx1;                     // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  REAL invdxx2;                     // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  REAL wavespeed_at_outer_boundary; // (nrpy.infrastructures.superB.timestepping_chare)
  REAL xxmax0;                      // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  REAL xxmax1;                      // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  REAL xxmax2;                      // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  REAL xxmin0;                      // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  REAL xxmin1;                      // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  REAL xxmin2;                      // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  bool grid_rotates;                // (nrpy.grid)
  char CoordSystemName[100];        // (nrpy.reference_metric)
  char gridname[100];               // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  int CoordSystem_hash;             // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  int Nxx0;                         // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  int Nxx1;                         // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  int Nxx2;                         // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  int Nxx_plus_2NGHOSTS0;           // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  int Nxx_plus_2NGHOSTS1;           // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  int Nxx_plus_2NGHOSTS2;           // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
  int grid_idx;                     // (nrpy.infrastructures.BHaH.numerical_grids_and_timestep)
} params_struct;

// ----------------------------
// Basic definitions for module
// finite_difference:
// ----------------------------

// Set the number of ghost zones
// Note that upwinding in e.g., BSSN requires that NGHOSTS = fd_order/2 + 1 <- Notice the +1.
#define NGHOSTS 5

// Declare NO_INLINE macro, used in FD functions. GCC v10+ compilations hang on complex RHS expressions (like BSSN) without this.
#if defined(__GNUC__) || defined(__clang__) || defined(__INTEL_COMPILER)
#define NO_INLINE __attribute__((noinline))
#elif defined(_MSC_VER)
#define NO_INLINE __declspec(noinline)
#else
#define NO_INLINE // Fallback for unknown compilers
#endif

// ----------------------------
// Basic definitions for module
// reference_metric:
// ----------------------------
typedef struct __rfmstruct__ {
  REAL *restrict f0_of_xx0;
  REAL *restrict f0_of_xx0__D0;
  REAL *restrict f0_of_xx0__DD00;
  REAL *restrict f0_of_xx0__DDD000;
  REAL *restrict f1_of_xx1;
  REAL *restrict f1_of_xx1__D1;
  REAL *restrict f1_of_xx1__DD11;
} rfm_struct;

// ----------------------------
// Basic definitions for module
// nrpy.infrastructures.BHaH.CurviBoundaryConditions.BHaH_defines:
// ----------------------------

// NRPy Curvilinear Boundary Conditions: Core data structures
// Documented in: Tutorial-Start_to_Finish-Curvilinear_BCs.ipynb

typedef struct __innerpt_bc_struct__ {
  int dstpt;         // dstpt is the 3D grid index IDX3S(i0,i1,i2) of the inner boundary point (i0,i1,i2)
  int srcpt;         // srcpt is the 3D grid index (a la IDX3S) to which the inner boundary point maps
  int8_t parity[10]; // parity[10] is a calculation of dot products for the 10 independent parity types
} innerpt_bc_struct;

typedef struct __outerpt_bc_struct__ {
  short i0, i1, i2;              // the outer boundary point grid index (i0,i1,i2), on the 3D grid
  int8_t FACEX0, FACEX1, FACEX2; // 1-byte integers that store
  //                               FACEX0,FACEX1,FACEX2 = +1, 0, 0 if on the i0=i0min face,
  //                               FACEX0,FACEX1,FACEX2 = -1, 0, 0 if on the i0=i0max face,
  //                               FACEX0,FACEX1,FACEX2 =  0,+1, 0 if on the i1=i2min face,
  //                               FACEX0,FACEX1,FACEX2 =  0,-1, 0 if on the i1=i1max face,
  //                               FACEX0,FACEX1,FACEX2 =  0, 0,+1 if on the i2=i2min face, or
  //                               FACEX0,FACEX1,FACEX2 =  0, 0,-1 if on the i2=i2max face,
} outerpt_bc_struct;

typedef struct __bc_info_struct__ {
  int num_inner_boundary_points;                  // stores total number of inner boundary points
  int num_inner_boundary_points_nonlocal;         // stores total number of inner boundary points that lie on another's grid
  int num_pure_outer_boundary_points[NGHOSTS][3]; // stores number of outer boundary points on each
  //                                                  ghostzone level and direction (update min and
  //                                                  max faces simultaneously on multiple cores)
  int bc_loop_bounds[NGHOSTS][6][6]; // stores outer boundary loop bounds. Unused after bcstruct_set_up()
} bc_info_struct;

typedef struct __bc_struct__ {
  innerpt_bc_struct *inner_bc_array;                   // information needed for updating each inner boundary point
  innerpt_bc_struct *inner_bc_array_nonlocal;          // information needed for updating each nonlocal inner boundary point
  outerpt_bc_struct *pure_outer_bc_array[NGHOSTS * 3]; // information needed for updating each outer
  //                                                             boundary point
  bc_info_struct bc_info; // stores number of inner and outer boundary points, needed for setting loop
  //                          bounds and parallelizing over as many boundary points as possible.
} bc_struct;

/* PARITY TYPES FOR EVOLVED (plus optional) GRIDFUNCTIONS.
 * SEE "Tutorial-Start_to_Finish-Curvilinear_BCs.ipynb" FOR DEFINITIONS. */
static const int8_t evol_gf_parity[2] = {0, 0};
static const int8_t aux_gf_parity[1] = {0};
static const int8_t auxevol_gf_parity[3] = {0, 0, 0};

// ----------------------------
// Basic definitions for module
// nrpy.infrastructures.BHaH.MoLtimestepping.BHaH_defines:
// ----------------------------
typedef struct __MoL_gridfunctions_struct__ {
  int num_evol_gfs_to_sync;
  int num_auxevol_gfs_to_sync;
  int num_aux_gfs_to_sync;
  int max_sync_gfs;
  int evol_gfs_to_sync[2];
  int auxevol_gfs_to_sync[0];
  int aux_gfs_to_sync[0];
  REAL *y_nplus1_running_total_gfs;
  REAL *k_odd_gfs;
  REAL *k_even_gfs;
  REAL *y_n_gfs;
  REAL *auxevol_gfs;
  REAL *diagnostic_output_gfs;
  REAL *y_n_gfs_initialdata_part1;
  REAL *y_n_gfs_initialdata_part2;

} MoL_gridfunctions_struct;
// Define constants for accessing gridfunction types
#define Y_NPLUS1_RUNNING_TOTAL_GFS 0
#define K_ODD_GFS 1
#define K_EVEN_GFS 2
#define Y_N_GFS 3
#define AUXEVOL_GFS 4
#define DIAGNOSTIC_OUTPUT_GFS 5
#define Y_N_GFS_INITIALDATA_PART1 6
#define Y_N_GFS_INITIALDATA_PART2 7
#define LOOP_ALL_GFS_GPS(ii)                                                                                                                         \
  _Pragma("omp parallel for") for (int(ii) = 0; (ii) < Nxx_plus_2NGHOSTS0 * Nxx_plus_2NGHOSTS1 * Nxx_plus_2NGHOSTS2 * NUM_EVOL_GFS; (ii)++)
// Define constants for rk substeps
#define RK_SUBSTEP_K1 1
#define RK_SUBSTEP_K2 2
#define RK_SUBSTEP_K3 3
#define RK_SUBSTEP_K4 4
// ----------------------------
// Basic definitions for module
// grid:
// ----------------------------

// EVOL VARIABLES:
#define NUM_EVOL_GFS 2
#define UUGF 0
#define VVGF 1

// SET gridfunctions_f_infinity[i] = evolved gridfunction i's value in the limit r->infinity:
static const REAL gridfunctions_f_infinity[NUM_EVOL_GFS] = {0.0, 0.0};

// SET gridfunctions_wavespeed[i] = evolved gridfunction i's characteristic wave speed:
static const REAL gridfunctions_wavespeed[NUM_EVOL_GFS] = {1.0, 1.0};

// AUX VARIABLES:
#define NUM_AUX_GFS 1
#define RESIDUAL_HGF 0

// AUXEVOL VARIABLES:
#define NUM_AUXEVOL_GFS 3
#define ADD_TIMES_AUUGF 0
#define PSI_BACKGROUNDGF 1
#define VARIABLE_WAVESPEEDGF 2

// ----------------------------
// Indexing macros
// ----------------------------
// IDX4: Converts 4D grid indices (gf, i, j, k) into a 1D array index using the strides
//       Nxx_plus_2NGHOSTS0, Nxx_plus_2NGHOSTS1, and Nxx_plus_2NGHOSTS2. This macro assumes
//       that the "i" index varies fastest in memory.
#define IDX4(gf, i, j, k) ((i) + Nxx_plus_2NGHOSTS0 * ((j) + Nxx_plus_2NGHOSTS1 * ((k) + Nxx_plus_2NGHOSTS2 * (gf))))
// IDX4P: Similar to IDX4, but retrieves grid dimensions from the provided parameter structure
//        "params" instead of using global variables.
#define IDX4P(params, gf, i, j, k)                                                                                                                   \
  ((i) + (params)->Nxx_plus_2NGHOSTS0 * ((j) + (params)->Nxx_plus_2NGHOSTS1 * ((k) + (params)->Nxx_plus_2NGHOSTS2 * (gf))))
// IDX4pt: Computes the 1D index offset for a given grid function index (gf) based on an existing index (idx)
//         by using the total number of elements in one grid function, defined as the product of the grid strides.
#define IDX4pt(gf, idx) ((idx) + (Nxx_plus_2NGHOSTS0 * Nxx_plus_2NGHOSTS1 * Nxx_plus_2NGHOSTS2) * (gf))
// IDX4ptP: Similar to IDX4pt, but retrieves grid dimensions from the provided parameter structure
//        "params" instead of using global variables.
#define IDX4Ppt(params, gf, idx) ((idx) + ((params)->Nxx_plus_2NGHOSTS0 * (params)->Nxx_plus_2NGHOSTS1 * (params)->Nxx_plus_2NGHOSTS2) * (gf))
// IDX3: Converts 3D grid indices (i, j, k) into a 1D array index using the strides Nxx_plus_2NGHOSTS0
//       and Nxx_plus_2NGHOSTS1. Like IDX4, this macro assumes the "i" index varies fastest.
#define IDX3(i, j, k) ((i) + Nxx_plus_2NGHOSTS0 * ((j) + Nxx_plus_2NGHOSTS1 * ((k))))
// IDX3P: Similar to IDX3, but retrieves grid dimensions from the provided parameter structure "params".
#define IDX3P(params, i, j, k) ((i) + (params)->Nxx_plus_2NGHOSTS0 * ((j) + (params)->Nxx_plus_2NGHOSTS1 * ((k))))
// END: Indexing macros

// ----------------------------
// Loop-related macros
// ----------------------------
// SET_NXX_PLUS_2NGHOSTS_VARS: Declares local constants for the grid dimensions (including ghost zones) by extracting
// the values from griddata[whichgrid].params.
#define SET_NXX_PLUS_2NGHOSTS_VARS(whichgrid)                                                                                                        \
  const int Nxx_plus_2NGHOSTS0 = griddata[whichgrid].params.Nxx_plus_2NGHOSTS0;                                                                      \
  const int Nxx_plus_2NGHOSTS1 = griddata[whichgrid].params.Nxx_plus_2NGHOSTS1;                                                                      \
  const int Nxx_plus_2NGHOSTS2 = griddata[whichgrid].params.Nxx_plus_2NGHOSTS2;
// LOOP_REGION: Iterates over a 3D region defined by the inclusive lower bounds (i0min, i1min, i2min)
// and exclusive upper bounds (i0max, i1max, i2max) for each dimension.
#define LOOP_REGION(i0min, i0max, i1min, i1max, i2min, i2max)                                                                                        \
  for (int i2 = i2min; i2 < i2max; i2++)                                                                                                             \
    for (int i1 = i1min; i1 < i1max; i1++)                                                                                                           \
      for (int i0 = i0min; i0 < i0max; i0++)
// LOOP_OMP: Similar to LOOP_REGION but inserts an OpenMP pragma (via __OMP_PRAGMA__) for parallelization.
#define LOOP_OMP(__OMP_PRAGMA__, i0, i0min, i0max, i1, i1min, i1max, i2, i2min, i2max)                                                               \
  _Pragma(__OMP_PRAGMA__) for (int(i2) = (i2min); (i2) < (i2max); (i2)++) for (int(i1) = (i1min); (i1) < (i1max);                                    \
                                                                               (i1)++) for (int(i0) = (i0min); (i0) < (i0max); (i0)++)
// LOOP_NOOMP: A non-parallel version of the 3D loop, identical in structure to LOOP_REGION.
#define LOOP_NOOMP(i0, i0min, i0max, i1, i1min, i1max, i2, i2min, i2max)                                                                             \
  for (int(i2) = (i2min); (i2) < (i2max); (i2)++)                                                                                                    \
    for (int(i1) = (i1min); (i1) < (i1max); (i1)++)                                                                                                  \
      for (int(i0) = (i0min); (i0) < (i0max); (i0)++)
// LOOP_BREAKOUT: Forces an exit from the nested loops by setting the loop indices to their maximum values and executing a break.
#define LOOP_BREAKOUT(i0, i1, i2, i0max, i1max, i2max)                                                                                               \
  {                                                                                                                                                  \
    i0 = (i0max);                                                                                                                                    \
    i1 = (i1max);                                                                                                                                    \
    i2 = (i2max);                                                                                                                                    \
    break;                                                                                                                                           \
  }
// IS_IN_GRID_INTERIOR: Checks whether the provided 3D index array (i0i1i2) lies within the grid interior,
// defined as the region excluding NG ghost cells on each boundary.
#define IS_IN_GRID_INTERIOR(i0i1i2, Nxx_plus_2NGHOSTS0, Nxx_plus_2NGHOSTS1, Nxx_plus_2NGHOSTS2, NG)                                                  \
  (i0i1i2[0] >= (NG) && i0i1i2[0] < (Nxx_plus_2NGHOSTS0) - (NG) && i0i1i2[1] >= (NG) && i0i1i2[1] < (Nxx_plus_2NGHOSTS1) - (NG) &&                   \
   i0i1i2[2] >= (NG) && i0i1i2[2] < (Nxx_plus_2NGHOSTS2) - (NG))

// ----------------------------
// Define griddata struct
// ----------------------------
typedef struct __griddata__ {
  // griddata_struct stores data needed on each grid
  // xx[3] stores the uniform grid coordinates.
  REAL *xx[3];
  // NRPy MODULE: nrpy.infrastructures.superB.diagnostics
  diagnostic_struct diagnosticstruct; // <- store indices of 1d and 2d diagnostic points, the offset in the output file, etc
  // NRPy MODULE: nrpy.infrastructures.superB.chare_communication_maps
  charecomm_struct charecommstruct; // <- maps that convert between index of a pt in chare's local grid to the index on the global grid, etc
  // NRPy MODULE: nrpy.infrastructures.superB.CurviBoundaryConditions
  bc_struct bcstruct;                           // <- all data needed to perform boundary conditions in curvilinear coordinates
  nonlocalinnerbc_struct nonlocalinnerbcstruct; // <- for communication of non-local inner boundary data across chares
  // NRPy MODULE: nrpy.infrastructures.superB.MoL
  MoL_gridfunctions_struct gridfuncs; // <- MoL gridfunctions
  // NRPy MODULE: nrpy.infrastructures.superB.timestepping_chare
  tmpBuffers_struct tmpBuffers; // <- temporary buffer for sending face data to neighbor chares
  // NRPy MODULE: params
  params_struct params; // <- BHaH parameters, generated from NRPy's CodeParameters
  // NRPy MODULE: reference_metric
  rfm_struct *rfmstruct; // <- includes e.g., 1D arrays of reference metric quantities
} griddata_struct;

// ----------------------------
// Basic definitions for module
// nrpy.infrastructures.BHaH.rfm_wrapper_functions:
// ----------------------------
#define SINHSPHERICAL 579707936

#ifndef BHAH_TYPEOF
#if __cplusplus >= 2000707L
#define BHAH_TYPEOF(a) decltype(a)
#elif defined(__GNUC__) || defined(__clang__) || defined(__NVCC__)
#define BHAH_TYPEOF(a) __typeof__(a)
#else
#define BHAH_TYPEOF(a)
#endif // END check for GCC, Clang, or C++
#endif // END BHAH_TYPEOF

#define BHAH_MALLOC(a, sz)                                                                                                                           \
  do {                                                                                                                                               \
    a = (BHAH_TYPEOF(a))malloc(sz);                                                                                                                  \
  } while (0);
#define BHAH_MALLOC__PtrMember(a, b, sz)                                                                                                             \
  do {                                                                                                                                               \
    if (a) {                                                                                                                                         \
      BHAH_MALLOC(a->b, sz);                                                                                                                         \
    }                                                                                                                                                \
  } while (0);

#define BHAH_FREE(a)                                                                                                                                 \
  do {                                                                                                                                               \
    if (a) {                                                                                                                                         \
      free((void *)(a));                                                                                                                             \
      (a) = NULL;                                                                                                                                    \
    }                                                                                                                                                \
  } while (0);
#define BHAH_FREE__PtrMember(a, b)                                                                                                                   \
  do {                                                                                                                                               \
    if (a) {                                                                                                                                         \
      BHAH_FREE(a->b);                                                                                                                               \
    }                                                                                                                                                \
  } while (0);

#ifdef __CUDACC__
/* Expand to the statement(s) you pass in */
#define IFCUDARUN(...)                                                                                                                               \
  do {                                                                                                                                               \
    {                                                                                                                                                \
      __VA_ARGS__;                                                                                                                                   \
    }                                                                                                                                                \
  } while (0)
#else
/* Compile away to nothing on non-CUDA builds */
#define IFCUDARUN(...)                                                                                                                               \
  do {                                                                                                                                               \
    {                                                                                                                                                \
      (void)0;                                                                                                                                       \
    }                                                                                                                                                \
  } while (0)
#endif
#endif
