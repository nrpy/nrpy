// BHaH core header file, automatically generated from output_BHaH_defines_h within BHaH_defines_h.py,
//    DO NOT EDIT THIS FILE BY HAND.

//********************************************
// Basic definitions for module general:
#include <ctype.h>
#include <errno.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
// output_BHaH_defines_h(...,enable_simd=True) was called so we #include SIMD intrinsics:
#include "TwoPunctures/TwoPunctures.h"
#include "simd/simd_intrinsics.h"
#define REAL double

#define MIN(A, B) (((A) < (B)) ? (A) : (B))
#define MAX(A, B) (((A) > (B)) ? (A) : (B))

//********************************************
// Basic definitions for module nrpy.infrastructures.BHaH.diagnostics.progress_indicator:
#ifdef __linux__
// Timer with nanosecond resolution. Only on Linux.
#define TIMEVAR struct timespec
#define CURRTIME_FUNC(currtime) clock_gettime(CLOCK_REALTIME, currtime)
#define TIME_IN_NS(start, end) (REAL)(1000000000L * (end.tv_sec - start.tv_sec) + end.tv_nsec - start.tv_nsec);
#else
// Low-resolution timer, 1-second resolution. Widely available.
#define TIMEVAR time_t
#define CURRTIME_FUNC(currtime) time(currtime)
#define TIME_IN_NS(start, end) (REAL)(difftime(end, start) * 1.0e9 + 1e-6) // Round up to avoid divide-by-zero.
#endif

//********************************************
// Basic definitions for module commondata_struct:
typedef struct __commondata_struct__ {
  REAL CFL_FACTOR;                     // nrpy.infrastructures.BHaH.MoLtimestepping.MoL::CFL_FACTOR
  REAL KreissOliger_strength_gauge;    // nrpy.infrastructures.BHaH.general_relativity.BSSN_C_codegen_library::KreissOliger_strength_gauge
  REAL KreissOliger_strength_nongauge; // nrpy.infrastructures.BHaH.general_relativity.BSSN_C_codegen_library::KreissOliger_strength_nongauge
  REAL TP_bare_mass_M;                 // TwoPunctures::TP_bare_mass_M
  REAL TP_bare_mass_m;                 // TwoPunctures::TP_bare_mass_m
  REAL bbhxy_BH_M_chix;                // nrpy.infrastructures.BHaH.general_relativity.NRPyPN_quasicircular_momenta::bbhxy_BH_M_chix
  REAL bbhxy_BH_M_chiy;                // nrpy.infrastructures.BHaH.general_relativity.NRPyPN_quasicircular_momenta::bbhxy_BH_M_chiy
  REAL bbhxy_BH_M_chiz;                // nrpy.infrastructures.BHaH.general_relativity.NRPyPN_quasicircular_momenta::bbhxy_BH_M_chiz
  REAL bbhxy_BH_m_chix;                // nrpy.infrastructures.BHaH.general_relativity.NRPyPN_quasicircular_momenta::bbhxy_BH_m_chix
  REAL bbhxy_BH_m_chiy;                // nrpy.infrastructures.BHaH.general_relativity.NRPyPN_quasicircular_momenta::bbhxy_BH_m_chiy
  REAL bbhxy_BH_m_chiz;                // nrpy.infrastructures.BHaH.general_relativity.NRPyPN_quasicircular_momenta::bbhxy_BH_m_chiz
  REAL checkpoint_every;               // nrpy.infrastructures.BHaH.checkpointing::checkpoint_every
  REAL convergence_factor;             // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::convergence_factor
  REAL diagnostics_output_every;       // nrpy.infrastructures.BHaH.general_relativity.BSSN_C_codegen_library::diagnostics_output_every
  REAL dt;                             // nrpy.infrastructures.BHaH.MoLtimestepping.MoL::dt
  REAL eta;                            // nrpy.equations.general_relativity.BSSN_gauge_RHSs::eta
  REAL initial_p_r;                    // nrpy.infrastructures.BHaH.general_relativity.NRPyPN_quasicircular_momenta::initial_p_r
  REAL initial_p_t;                    // nrpy.infrastructures.BHaH.general_relativity.NRPyPN_quasicircular_momenta::initial_p_t
  REAL initial_sep;                    // nrpy.infrastructures.BHaH.general_relativity.NRPyPN_quasicircular_momenta::initial_sep
  REAL mass_M;                         // nrpy.infrastructures.BHaH.general_relativity.NRPyPN_quasicircular_momenta::mass_M
  REAL mass_m;                         // nrpy.infrastructures.BHaH.general_relativity.NRPyPN_quasicircular_momenta::mass_m
  REAL mass_ratio;                     // nrpy.infrastructures.BHaH.general_relativity.NRPyPN_quasicircular_momenta::mass_ratio
  REAL t_0;                            // nrpy.infrastructures.BHaH.MoLtimestepping.MoL::t_0
  REAL t_final;                        // nrpy.infrastructures.BHaH.MoLtimestepping.MoL::t_final
  REAL time;                           // nrpy.infrastructures.BHaH.MoLtimestepping.MoL::time
  TIMEVAR start_wallclock_time;        // nrpy.infrastructures.BHaH.diagnostics.progress_indicator::start_wallclock_time
  int NUMGRIDS;                        // nrpy.grid::NUMGRIDS
  int TP_npoints_A;                    // TwoPunctures::TP_npoints_A
  int TP_npoints_B;                    // TwoPunctures::TP_npoints_B
  int TP_npoints_phi;                  // TwoPunctures::TP_npoints_phi
  int nn;                              // nrpy.infrastructures.BHaH.MoLtimestepping.MoL::nn
  int nn_0;                            // nrpy.infrastructures.BHaH.MoLtimestepping.MoL::nn_0
  int swm2sh_maximum_l_mode_to_compute; // nrpy.infrastructures.BHaH.special_functions.spin_weight_minus2_spherical_harmonics::swm2sh_maximum_l_mode_to_compute
  char TP_BBH_description[100]; // TwoPunctures::TP_BBH_description
  char outer_bc_type[50];       // nrpy.infrastructures.BHaH.CurviBoundaryConditions.CurviBoundaryConditions::outer_bc_type
} commondata_struct;

//********************************************
// Basic definitions for module params_struct:
typedef struct __params_struct__ {
  REAL AMPL;                // nrpy.reference_metric_SinhSpherical::AMPL
  REAL Cart_originx;        // nrpy.grid::Cart_originx
  REAL Cart_originy;        // nrpy.grid::Cart_originy
  REAL Cart_originz;        // nrpy.grid::Cart_originz
  REAL SINHW;               // nrpy.reference_metric_SinhSpherical::SINHW
  REAL dxx0;                // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::dxx0
  REAL dxx1;                // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::dxx1
  REAL dxx2;                // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::dxx2
  REAL f0_of_xx0;           // nrpy.reference_metric_SinhSpherical::f0_of_xx0
  REAL f0_of_xx0__D0;       // nrpy.reference_metric_SinhSpherical::f0_of_xx0__D0
  REAL f0_of_xx0__DD00;     // nrpy.reference_metric_SinhSpherical::f0_of_xx0__DD00
  REAL f0_of_xx0__DDD000;   // nrpy.reference_metric_SinhSpherical::f0_of_xx0__DDD000
  REAL f1_of_xx1;           // nrpy.reference_metric_SinhSpherical::f1_of_xx1
  REAL f1_of_xx1__D1;       // nrpy.reference_metric_SinhSpherical::f1_of_xx1__D1
  REAL f1_of_xx1__DD11;     // nrpy.reference_metric_SinhSpherical::f1_of_xx1__DD11
  REAL f1_of_xx1__DDD111;   // nrpy.reference_metric_SinhSpherical::f1_of_xx1__DDD111
  REAL f2_of_xx0;           // nrpy.reference_metric_SinhSpherical::f2_of_xx0
  REAL f2_of_xx0__D0;       // nrpy.reference_metric_SinhSpherical::f2_of_xx0__D0
  REAL f2_of_xx0__DD00;     // nrpy.reference_metric_SinhSpherical::f2_of_xx0__DD00
  REAL f3_of_xx2;           // nrpy.reference_metric_SinhSpherical::f3_of_xx2
  REAL f3_of_xx2__D2;       // nrpy.reference_metric_SinhSpherical::f3_of_xx2__D2
  REAL f3_of_xx2__DD22;     // nrpy.reference_metric_SinhSpherical::f3_of_xx2__DD22
  REAL f4_of_xx1;           // nrpy.reference_metric_SinhSpherical::f4_of_xx1
  REAL f4_of_xx1__D1;       // nrpy.reference_metric_SinhSpherical::f4_of_xx1__D1
  REAL f4_of_xx1__DD11;     // nrpy.reference_metric_SinhSpherical::f4_of_xx1__DD11
  REAL f4_of_xx1__DDD111;   // nrpy.reference_metric_SinhSpherical::f4_of_xx1__DDD111
  REAL grid_physical_size;  // nrpy.reference_metric::grid_physical_size
  REAL invdxx0;             // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::invdxx0
  REAL invdxx1;             // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::invdxx1
  REAL invdxx2;             // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::invdxx2
  REAL xxmax0;              // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::xxmax0
  REAL xxmax1;              // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::xxmax1
  REAL xxmax2;              // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::xxmax2
  REAL xxmin0;              // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::xxmin0
  REAL xxmin1;              // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::xxmin1
  REAL xxmin2;              // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::xxmin2
  int CoordSystem_hash;     // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::CoordSystem_hash
  int Nxx0;                 // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::Nxx0
  int Nxx1;                 // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::Nxx1
  int Nxx2;                 // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::Nxx2
  int Nxx_plus_2NGHOSTS0;   // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::Nxx_plus_2NGHOSTS0
  int Nxx_plus_2NGHOSTS1;   // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::Nxx_plus_2NGHOSTS1
  int Nxx_plus_2NGHOSTS2;   // nrpy.infrastructures.BHaH.numerical_grids_and_timestep::Nxx_plus_2NGHOSTS2
  char CoordSystemName[50]; // nrpy.reference_metric::CoordSystemName
} params_struct;

//********************************************
// Basic definitions for module finite_difference:

// Set the number of ghost zones
// Note that upwinding in e.g., BSSN requires that NGHOSTS = fd_order/2 + 1 <- Notice the +1.
#define NGHOSTS 5

//********************************************
// Basic definitions for module reference_metric:
typedef struct __rfmstruct__ {
  REAL *restrict f0_of_xx0;
  REAL *restrict f0_of_xx0__D0;
  REAL *restrict f0_of_xx0__DD00;
  REAL *restrict f0_of_xx0__DDD000;
  REAL *restrict f1_of_xx1;
  REAL *restrict f1_of_xx1__D1;
  REAL *restrict f1_of_xx1__DD11;
} rfm_struct;

//********************************************
// Basic definitions for module nrpy.infrastructures.BHaH.CurviBoundaryConditions.CurviBoundaryConditions:

// NRPy+ Curvilinear Boundary Conditions: Core data structures
// Documented in: Tutorial-Start_to_Finish-Curvilinear_BCs.ipynb

typedef struct __innerpt_bc_struct__ {
  int dstpt;         // dstpt is the 3D grid index IDX3S(i0,i1,i2) of the inner boundary point (i0,i1,i2)
  int srcpt;         // srcpt is the 3D grid index (a la IDX3S) to which the inner boundary point maps
  int8_t parity[10]; // parity[10] is a calculation of dot products for the 10 independent parity types
} innerpt_bc_struct;

typedef struct __outerpt_bc_struct__ {
  short i0, i1, i2;              // the outer boundary point grid index (i0,i1,i2), on the 3D grid
  int8_t FACEX0, FACEX1, FACEX2; // 1-byte integers that store
  //                               FACEX0,FACEX1,FACEX2 = +1, 0, 0 if on the i0=i0min face,
  //                               FACEX0,FACEX1,FACEX2 = -1, 0, 0 if on the i0=i0max face,
  //                               FACEX0,FACEX1,FACEX2 =  0,+1, 0 if on the i1=i2min face,
  //                               FACEX0,FACEX1,FACEX2 =  0,-1, 0 if on the i1=i1max face,
  //                               FACEX0,FACEX1,FACEX2 =  0, 0,+1 if on the i2=i2min face, or
  //                               FACEX0,FACEX1,FACEX2 =  0, 0,-1 if on the i2=i2max face,
} outerpt_bc_struct;

typedef struct __bc_info_struct__ {
  int num_inner_boundary_points;                  // stores total number of inner boundary points
  int num_pure_outer_boundary_points[NGHOSTS][3]; // stores number of outer boundary points on each
  //                                                  ghostzone level and direction (update min and
  //                                                  max faces simultaneously on multiple cores)
  int bc_loop_bounds[NGHOSTS][6][6]; // stores outer boundary loop bounds. Unused after bcstruct_set_up()
} bc_info_struct;

typedef struct __bc_struct__ {
  innerpt_bc_struct *restrict inner_bc_array;                   // information needed for updating each inner boundary point
  outerpt_bc_struct *restrict pure_outer_bc_array[NGHOSTS * 3]; // information needed for updating each outer
  //                                                             boundary point
  bc_info_struct bc_info; // stores number of inner and outer boundary points, needed for setting loop
  //                          bounds and parallelizing over as many boundary points as possible.
} bc_struct;

/* PARITY TYPES FOR EVOLVED (plus optional) GRIDFUNCTIONS.
 * SEE "Tutorial-Start_to_Finish-Curvilinear_BCs.ipynb" FOR DEFINITIONS. */
static const int8_t evol_gf_parity[24] = {4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 1, 2, 3, 0, 1, 2, 3};

//********************************************
// Basic definitions for module nrpy.infrastructures.BHaH.MoLtimestepping.MoL:
typedef struct __MoL_gridfunctions_struct__ {
  REAL *restrict y_n_gfs;
  REAL *restrict y_nplus1_running_total_gfs;
  REAL *restrict k_odd_gfs;
  REAL *restrict k_even_gfs;
  REAL *restrict auxevol_gfs;
  REAL *restrict diagnostic_output_gfs;
  REAL *restrict diagnostic_output_gfs2;
} MoL_gridfunctions_struct;

#define LOOP_ALL_GFS_GPS(ii)                                                                                                                         \
  _Pragma("omp parallel for") for (int(ii) = 0; (ii) < Nxx_plus_2NGHOSTS0 * Nxx_plus_2NGHOSTS1 * Nxx_plus_2NGHOSTS2 * NUM_EVOL_GFS; (ii)++)

//********************************************
// Basic definitions for module grid:

// EVOL VARIABLES:
#define NUM_EVOL_GFS 24
#define ADD00GF 0
#define ADD01GF 1
#define ADD02GF 2
#define ADD11GF 3
#define ADD12GF 4
#define ADD22GF 5
#define ALPHAGF 6
#define BETU0GF 7
#define BETU1GF 8
#define BETU2GF 9
#define CFGF 10
#define HDD00GF 11
#define HDD01GF 12
#define HDD02GF 13
#define HDD11GF 14
#define HDD12GF 15
#define HDD22GF 16
#define LAMBDAU0GF 17
#define LAMBDAU1GF 18
#define LAMBDAU2GF 19
#define TRKGF 20
#define VETU0GF 21
#define VETU1GF 22
#define VETU2GF 23

// SET gridfunctions_f_infinity[i] = evolved gridfunction i's value in the limit r->infinity:
static const REAL gridfunctions_f_infinity[NUM_EVOL_GFS] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
                                                            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};

// SET gridfunctions_wavespeed[i] = evolved gridfunction i's characteristic wave speed:
static const REAL gridfunctions_wavespeed[NUM_EVOL_GFS] = {
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.41421356237310, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0};

// AUX VARIABLES:
#define NUM_AUX_GFS 8
#define HGF 0
#define MSQUAREDGF 1
#define PSI4_PART0IMGF 2
#define PSI4_PART0REGF 3
#define PSI4_PART1IMGF 4
#define PSI4_PART1REGF 5
#define PSI4_PART2IMGF 6
#define PSI4_PART2REGF 7

// AUXEVOL VARIABLES:
#define NUM_AUXEVOL_GFS 6
#define RBARDD00GF 0
#define RBARDD01GF 1
#define RBARDD02GF 2
#define RBARDD11GF 3
#define RBARDD12GF 4
#define RBARDD22GF 5

// Declare the IDX4(gf,i,j,k) macro, which enables us to store 4-dimensions of
//   data in a 1D array. In this case, consecutive values of "i"
//   (all other indices held to a fixed value) are consecutive in memory, where
//   consecutive values of "j" (fixing all other indices) are separated by
//   Nxx_plus_2NGHOSTS0 elements in memory. Similarly, consecutive values of
//   "k" are separated by Nxx_plus_2NGHOSTS0*Nxx_plus_2NGHOSTS1 in memory, etc.
#define IDX4(g, i, j, k) ((i) + Nxx_plus_2NGHOSTS0 * ((j) + Nxx_plus_2NGHOSTS1 * ((k) + Nxx_plus_2NGHOSTS2 * (g))))
#define IDX4pt(g, idx) ((idx) + (Nxx_plus_2NGHOSTS0 * Nxx_plus_2NGHOSTS1 * Nxx_plus_2NGHOSTS2) * (g))
#define IDX3(i, j, k) ((i) + Nxx_plus_2NGHOSTS0 * ((j) + Nxx_plus_2NGHOSTS1 * ((k))))
#define LOOP_REGION(i0min, i0max, i1min, i1max, i2min, i2max)                                                                                        \
  for (int i2 = i2min; i2 < i2max; i2++)                                                                                                             \
    for (int i1 = i1min; i1 < i1max; i1++)                                                                                                           \
      for (int i0 = i0min; i0 < i0max; i0++)
#define LOOP_OMP(__OMP_PRAGMA__, i0, i0min, i0max, i1, i1min, i1max, i2, i2min, i2max)                                                               \
  _Pragma(__OMP_PRAGMA__) for (int(i2) = (i2min); (i2) < (i2max); (i2)++) for (int(i1) = (i1min); (i1) < (i1max);                                    \
                                                                               (i1)++) for (int(i0) = (i0min); (i0) < (i0max); (i0)++)
#define LOOP_NOOMP(i0, i0min, i0max, i1, i1min, i1max, i2, i2min, i2max)                                                                             \
  for (int(i2) = (i2min); (i2) < (i2max); (i2)++)                                                                                                    \
    for (int(i1) = (i1min); (i1) < (i1max); (i1)++)                                                                                                  \
      for (int(i0) = (i0min); (i0) < (i0max); (i0)++)
#define LOOP_BREAKOUT(i0, i1, i2, i0max, i1max, i2max)                                                                                               \
  {                                                                                                                                                  \
    i0 = (i0max);                                                                                                                                    \
    i1 = (i1max);                                                                                                                                    \
    i2 = (i2max);                                                                                                                                    \
    break;                                                                                                                                           \
  }
#define IS_IN_GRID_INTERIOR(i0i1i2, Nxx_plus_2NGHOSTS0, Nxx_plus_2NGHOSTS1, Nxx_plus_2NGHOSTS2, NG)                                                  \
  (i0i1i2[0] >= (NG) && i0i1i2[0] < (Nxx_plus_2NGHOSTS0) - (NG) && i0i1i2[1] >= (NG) && i0i1i2[1] < (Nxx_plus_2NGHOSTS1) - (NG) &&                   \
   i0i1i2[2] >= (NG) && i0i1i2[2] < (Nxx_plus_2NGHOSTS2) - (NG))

typedef struct __griddata__ {
  // griddata_struct stores data needed on each grid
  // xx[3] stores the uniform grid coordinates.
  REAL *restrict xx[3];
  // NRPy+ MODULE: nrpy.infrastructures.BHaH.CurviBoundaryConditions.CurviBoundaryConditions
  bc_struct bcstruct; // <- all data needed to perform boundary conditions in curvilinear coordinates
  // NRPy+ MODULE: nrpy.infrastructures.BHaH.MoLtimestepping.MoL
  MoL_gridfunctions_struct gridfuncs; // <- MoL gridfunctions
  // NRPy+ MODULE: params
  params_struct params; // <- BHaH parameters, generated from NRPy+'s CodeParameters
  // NRPy+ MODULE: reference_metric
  char CoordSystemname[100]; // <- the name of the CoordSystem (from reference_metric)
  char gridname[100];        // <- a user-defined alias for describing the grid
  rfm_struct rfmstruct;      // <- includes e.g., 1D arrays of reference metric quantities
} griddata_struct;

//********************************************
// Basic definitions for module nrpy.infrastructures.BHaH.general_relativity.ADM_Initial_Data_Reader__BSSN_Converter:
typedef struct __initial_data_struct__ {
  REAL alpha;

  REAL betaSphorCartU0, betaSphorCartU1, betaSphorCartU2;
  REAL BSphorCartU0, BSphorCartU1, BSphorCartU2;

  REAL gammaSphorCartDD00, gammaSphorCartDD01, gammaSphorCartDD02;
  REAL gammaSphorCartDD11, gammaSphorCartDD12, gammaSphorCartDD22;

  REAL KSphorCartDD00, KSphorCartDD01, KSphorCartDD02;
  REAL KSphorCartDD11, KSphorCartDD12, KSphorCartDD22;

} initial_data_struct;
typedef struct __ID_persist_struct__ {

  derivs v;    // stores coefficients
  derivs cf_v; // stores coefficients

  REAL mp, mm, mp_adm, mm_adm, E, J1, J2, J3;

  int npoints_A;    // Number of coefficients in the compactified radial direction
  int npoints_B;    // Number of coefficients in the angular direction
  int npoints_phi;  // Number of coefficients in the phi direction
  int Newton_maxit; // Maximum number of Newton iterations

  REAL adm_tol;                    // Tolerance of ADM masses when give_bare_mass=no
  REAL Newton_tol;                 // Tolerance for Newton solver
  REAL TP_epsilon;                 // A small number to smooth out singularities at the puncture locations
  REAL TP_Tiny;                    // Tiny number to avoid nans near or at the pucture locations
  REAL TP_Extend_Radius;           // Radius of an extended spacetime instead of the puncture
  REAL par_b;                      // x coordinate of the m+ puncture STEERABLE=always
  REAL par_m_plus;                 // mass of the m+ puncture STEERABLE = ALWAYS
  REAL par_m_minus;                // mass of the m- puncture STEERABLE = ALWAYS
  REAL target_M_plus;              // target ADM mass for m+
  REAL target_M_minus;             // target ADM mass for m-
  REAL par_P_plus[3];              // momentum of the m+ puncture
  REAL par_P_minus[3];             // momentum of the m- puncture
  REAL par_S_plus[3];              // spin of the m+ puncture
  REAL par_S_minus[3];             // spin of the m- puncture
  REAL center_offset[3];           // offset b=0 to position (x,y,z)
  REAL initial_lapse_psi_exponent; // Exponent n for psi^-n initial lapse profile

  bool verbose;         // Print screen output while solving
  bool keep_u_around;   // Keep the variable u around after solving
  bool give_bare_mass;  // User provides bare masses rather than target ADM masses
  bool swap_xz;         // Swap x and z coordinates when interpolating, so that the black holes are separated in the z direction
  bool use_sources;     // Use sources?
  bool rescale_sources; // If sources are used - rescale them after solving?
  // bool use_external_initial_guess; //Set initial guess by external function?
  bool do_residuum_debug_output;  // Output debug information about the residuum
  bool do_initial_debug_output;   // Output debug information about initial guess
  bool multiply_old_lapse;        // Multiply the old lapse with the new one
  bool solve_momentum_constraint; // Solve for momentum constraint?

  char grid_setup_method[100]; // How to fill the 3D grid from the spectral grid
  char initial_lapse[100];     // initial lapse

} ID_persist_struct;

//********************************************
// Basic definitions for module nrpy.infrastructures.BHaH.rfm_wrapper_functions:
#define SINHSPHERICAL 579707936
